There was effort on Go NaCl support at one point, which is similar to what
you're suggesting.  Have you taken a look at Dart?  To me, it seems a much
more suitable replacement for JavaScript than Go does.
I just was thinking about to use Go directly from the browser,
independently of having a compiler from Go to JavaScript.
At the first, my idea was to build a VM for Go. But it isn't really
necessary since there are tools to run Go code like if were scripts.
I think that to run Go code from our brwsers would be "as easy" like
(1) to install the Go toolchain (command go) together to its compiled
libraries (about 45 MB) --except some libraries or functions which
could be unsafe like functions in package "os" or library "unsafe"--.
(2) And of course, the browser should be allowed to use the Go
toolchain; this is the key point. Does anybody with experience in
browsers could say me if it's possible?
Advantages:
+ One same specification so our code doesn't breaks in different
browsers. This is a great problem in JS (thanks Microsoft)
+ One only language for all development, and all advantages of Go
+ The third libraries could be cached so it would speed up the web
applications.
And in a short time, I'll can use a language with a clean sintaxis and
non-verbose like Go for the client-side although the way to get it is
compiling Go to JS, by now.
as Java for the client-side if I can choose.
NaCl is different to my proposal since NaCl was built to run native
code in the web so code already compiled; (which I think that it would
be very bad since we would get a "dark web" where you cann't know what
is going to do the NaCl program). My proposal is about compile Go
programs from the browser.
NaCl does a sandox to avoid to access to some system calls. But it
isn't necessary from a Go program because it cann't access directly to
the system calls; it would be as easy like avoid the calling of C
libraries from Go code.
Hello. Now bitbucket officially provide git repo hosting, if i want to
install package from bitbucket git repo, what i need to do?
goinstall not able to fetch git repos, becouse it thinks, that bitbucket
contains only mercurial repos.
-- 
Vasiliy Tolstov,
Clodo.ru
e-mail: v.to...@selfip.ru
jabber: va...@selfip.ru
I've submitted a CL to add support: 
-- 
Julian
2011/10/26 Julian Phillips <jul...@quantumfyre.co.uk>
Thanks!
-- 
Vasiliy Tolstov,
Clodo.ru
e-mail: v.to...@selfip.ru
jabber: va...@selfip.ru
I think you'll have to use the explicit goinstall form:
2011/10/25 Dmitry Chestnykh <dch...@gmail.com>
Can it possible to fix that in next release ?:)
-- 
Vasiliy Tolstov,
Clodo.ru
e-mail: v.to...@selfip.ru
jabber: va...@selfip.ru
Forgot to reference this:
-- 
Aram Hăvărneanu
golang Google search are much better to find golang related results
than it was on 2009.
go get is embraced and most of the active projects uses it. Maybe you
reached project that isn't very active or the project simply requires
too much custom build steps to be "go gettable"
go-webkit/WKA: Those are wrappers around webkit engine. go-webkit uses
the go-gtk bindings and gtkwebkit.
go-gtk: bindings for GTK 2. This binding is really good
go-uik: this is a user interface toolkit in pure Go, it uses go-wde
for rasterization and event capturing, but this project is only
starting so don't expect any great collection of widgets.
go-wde: low level API for rendering things and capturing events, this
one requires CGO
-- 
André Moraes
John Asmuth's go.wde and go.uik would be ideal choices for creating the
graphics part of sam.
-- 
Aram Hăvărneanu
Haha, I suppose I don't know enough about SAM.
There is no multi-line text area widget, yet...
Yes, that's why I explicitly answered it's good for implementing the
graphics part of sam. It might not be good for everyone and everything, but it's
certainly good enough for sam.
-- 
Aram Hăvărneanu
It looks like cmd.Start does that:
(Just don't use the Wait().)
You can tell them your application depends on Chrome being installed
and fire an external process from your Go app pointing the browser to
localhost.
Not sure that would be required, you can just tweak the CEF example
application in minor ways to run the go executable -- have them
communicate however you want (zeromq, websockets).  As long as you can
build an installer to put them in the same place, should be golden.
-- 
Robert Melton
AFAIK, node-webkit have versions for windows/macos/linux.
The look and feel of the window is native, you can't tell the
diference between a node-webkit window and a win32 window.
I think you could be able to set the size of the window without any
problems, but you should check node-webkit docs to be sure.
The renderer is the same, so, if you can use chrome you should be able
to use node-webkit.
-- 
André Moraes
2013/8/9 bronze man <bronz...@gmail.com>
How I do it:
create a simple html page using node-webkit (this project combines
chromiun source code with nodejs)
After that html page is loaded, I use nodejs stdlibrary to fire my go
application and create a websocket to do I/O.
Everything else is done inside Go.
-- 
André Moraes
Yes. fmt.Fprint will interpret %-verbs in the string, so if you might
have %-characters in that string, beware.
[I assume your question was more general than just for the specific
 string "str".]
Chris
-- 
Chris "allusive" Dollin
No. Fprint does not use format strings, Fprintf does.
--Benny.
-- 
The first essential in chemistry is that you should perform practical
work and conduct experiments, for he who performs not practical work
nor makes experiments will never attain the least degree of mastery.
        -- Abu Musa Jabir ibn Hayyan (721-815)
(fx:peers-closely)
Dagnabbit. So it isn't.
Thanks for catching it.
Chris
-- 
Chris "allusive" Dollin
Is there any difference between to use `fmt.Fprint(os.Stdout, "str")`
and `os.Stdout.Write([]byte("str"))` ?
I'm using now `os.Stdout.Write` to write ANSI terminal escape controls.
If all you want to do is output specific byte strings (and not do any
string formatting) you can just write straight to os.Stdout. fmt will
do the same thing eventually, so if you don't need any of its
functionality you might as well skip it.
Andrew
Fprint can print any data type, while Stdout.Write only prints byte
slices.
-Daniel
Hi,
I've released a tool to manage machine images from multiple providers:
It's still very alpha and I'm developing it but I think it's good to
go. Any feedback and contribution is welcome.
Regards
-- 
Fatih Arslan
Sorry, I only needed to cast the variable:
   memoryBlock[2] = byte(256 - (187 - int(memoryBlock[2])))
So since you're assigning to a byte I think Go is treating all of the
constants as bytes.  A byte can only encode between 0 and 255. You need
an extra bit (ie, more than a byte) to store 256.   Something like the
following works but might be silly:
 memoryBlock[2] = byte(int(256) - (187 - int(memoryBlock[2])))
vase <v.to...@selfip.ru> writes:
Go does not currently support loading shared libraries.
Ian
Hello. I'm try to learn go language, now i have C daemon, that listens
sock for json requests.
All request served by C shared libraries, that dinamyc loaded at
runtime (listed in config file). After daemon recieves reuests it
passes it to module and waiting for response, after that serves it to
client.
I'm not able re find any threads about ability to run module from go
language.
How can i extent base daemon functions using modules in case of use
Go? Is that possible?
If not - what i need to to in my case?
Finally i want to have 1 daemon, that able to use modules. If i need
new functions in my daemon - i get module and discribe commands that
it serves...
P.S. If i want to write support for specific protocol (in my case -
xenstore, used in Xen domU). What i need to do?
Thank You for all suggestions..
Go doesn't support dynamic loading of Go code into the same process space.
Here are a few different ideas to achieve what you want:
1) Use the standard rpc and gob modules to talk to an external Go
process over a well defined API.
2) Define a simple protocol and implement it through unix sockets, or
even stdin/out between processes.  This has the advantage that plugins
can be in any language.
3) Embed a dynamic language in your project.  Lua is a good candidate,
for instance.
There are other ways, but this should serve to inspire you.
-- 
Gustavo Niemeyer
-- I never filed a patent.
Can't it be done with cgo and then loading libraries from C?
the usual solution to this is to close the channel and then wait for
the thing at the other end to signal that it's finished.
for that, sync.WaitGroup can be a nice solution.
Gustavo Niemeyer's tomb package (see
can also provide a useful structure in this kind of situation, particularly
if you want to retrieve errors.
I've come across this situation a few times while writing go applications
and I was wondering what the best way to handle it is.
Say you have a package for sending email that has a buffered channel and a
goroutine processing the channel and sending the email.
Then in your application, to send an email, you put the data on the channel
and it gets sent asynchronously.
If your application exits before the goroutine has a chance to process all
the elements in the channel, some emails never gets sent.
So what is the best way to handle this?
My guess would be to call a shutdown function in the email package before
exiting the application (either via trapping the quit/interrupt signals or
calling it before exiting main()).  In the shutdown function, close the
channel then wait for the channel to become empty.
But I imagine there is an elegant solution that I don't know about.  Any
tips would be much appreciated.
Thanks,
Tom
We know about the problem.  Unfortunately, Google Groups is a
large target.  It's very hard to do the job perfectly.  I am sure that
far more spam is being rejected than getting through.
Russ
Spam from this mailing-list is of annoyance to the subscriber. Please
look into the issue.
S.
You are correct. gomake uses make, so you need mingw. You could run all compile and link commands (8g and 8l) by hand or put them in a batch file, but that is too verbose and sometimes complicated.
I hope, it will change soon. I believe, goinstall is getting rewritten at this moment, so it can be used as replacement for gomake.
Alex
How do you build packages by hand (gomake don't work) in windows ?
Hi All,
I am developing a JSON REST API server.
Currently i use one struct to save the resource and also to receive the 
REST request. And now considering to use separate struct to receive the 
request.
Let me give simplified example:
Id, CreatedAt, and UpdatedAt should not be generated by the system, not 
by external input.
So, i need to check if client defining above values in (e.g.) POST and 
then strip it.
That's why i created another struct to handle the request.
By using another struct to handle request, i don't need to strip Id, 
CreatedAt, and UpdatedAt at the POST/PUT request.
But using another struct will create some maintainability issue, where i 
need to make sure that ResRequest also updated (when needed) when there 
is update to Res.
By using one struct, receiving request and saving it to DB become very 
simple (I use gorm ).
It is something like this:
  var r Res
  json.Unmarshal(b, &r)
  db.Save(r)
  WriteHeader(201)
  writeJson(&r)
Which method that you think more idiomatic and better in Go point of view?
Thanks
also,
-brad
Also, change "Imports" to "Deps" to get all recursive dependencies
DEPS=$(go list -f $',')
-- 
Fatih Arslan
From go test -help:
    -coverpkg pkg1,pkg2,pkg3
        Apply coverage analysis in each test to the given list of
packages. The default is for each test to analyze only the package being
tested. Packages are specified as import paths.
E.g. in the directory for package A, run "go test -coverpkg A,B,C".
    -Chris K
Is there any way to automatically include the dependent packages ? I don't
see that mentioned in the help.
DEPS=$(go list -f $',')
go test -coverpkg=$DEPS
This will include all your imports. The output will be like:
PASS
coverage: 19.5% of statements in errors, fmt, reflect, strings,
ok  	github.com/fatih/structs	0.008s
-- 
Fatih Arslan
If all you're trying to do is get coverage of all your subpackages for a CI
and aren't concerned about downstream packages or manually toggling which
ones are one/off at runtime, I've used this script:
with Travis, and it seems to work fine.
-- 
- Dave
Thanks, it was very helpful. I am trying to modify it to output only a set
of packages starting with some prefix. Hopefully i'll get it done soon :)
Thanks once again.
Done, if you add an encoding/json benchmark with the same input then autobench will pick that up automatically. 
Thanks, Ugorji. This library is indeed awesome!
-- 
DISCLAIMER:
This is not an investment recommendation or a solicitation to become an 
investor of the firm. Unless indicated, these views are the author's and 
may differ from those of the firm or others in the firm. We do not 
represent this is accurate or complete and we may not update this. Past 
performance is not indicative of future returns. For additional information 
and important disclosures, contact me at this email address. You should not 
use email to request or authorize the investment in any security or 
instrument, or to effect any other transactions. We cannot guarantee that 
any such requests received via email will be processed in a timely manner. 
This communication is solely for the addressee(s) and may contain 
confidential information. We do not waive confidentiality by 
mistransmission. Contact me if you do not wish to receive these 
communications.
Robert-
Let me know how it works for you. Test coverage is about 80% but I'm going to bump that up soon. It's only about 1200 LOC so it shouldn't be too hard to grok. Let me know if you have any questions.
Bug reports and pull requests are always welcome. :)
Ben
Alberto, sorry to necro this thread, but: do you still plan to release this 
optimized JSON library?
wrote:
-- 
DISCLAIMER:
This is not an investment recommendation or a solicitation to become an 
investor of the firm. Unless indicated, these views are the author's and 
may differ from those of the firm or others in the firm. We do not 
represent this is accurate or complete and we may not update this. Past 
performance is not indicative of future returns. For additional information 
and important disclosures, contact me at this email address. You should not 
use email to request or authorize the investment in any security or 
instrument, or to effect any other transactions. We cannot guarantee that 
any such requests received via email will be processed in a timely manner. 
This communication is solely for the addressee(s) and may contain 
confidential information. We do not waive confidentiality by 
mistransmission. Contact me if you do not wish to receive these 
communications.
Hi Ben,
With your permission I'd like to add megajson to my autobench harness [1]
Here is some raw data comparing megajson running on 1.1.2 vs 1.2rc3
#megajson
benchmark               old ns/op    new ns/op    delta
BenchmarkCodeEncoder     20810857     15047966  -27.69%
BenchmarkCodeDecoder     75351857     54290820  -27.95%
benchmark                old MB/s     new MB/s  speedup
BenchmarkCodeEncoder        93.24       128.95    1.38x
BenchmarkCodeDecoder        25.75        35.74    1.39x
hey Dave-
That'd be great if you could add it to autobench. It'll be interesting to see how raw code vs encoding/json's reflection-based approach improve over time.
Thanks!
Ben
Ben--
Thanks!
This is very timely, we were just considering starting work on a very
similar package, I look forward to taking it for a spin.
-- 
Robert Melton
Hi everyone-
I've hit performance bottlenecks with JSON encoding on two projects (sky & goraft) so I wrote an alternative called megajson. I noticed that a lot of CPU time went to the "reflect" package to determine the appropriate types to serialize so megajson takes the approach of generating parsers using the "go/ast" package at compile time.
It's still in an alpha stage but I thought I'd post it to get some feedback from people around my approach.
Using the test data in encoding/json, megajson encodes and decodes about 2x faster. Obviously, YMMV.
Special thanks to Shopify for sponsoring the work on it.
Ben Johnson
[bcc: golang-dev]
If you think proto.Unmarshal(data, pb) clears the old content of pb,
you can stop reading now.
The current behavior of proto.Unmarshal(data, pb) is actually to write
the information from data into pb but leave untouched any old
information that is not explicitly overwritten or that lives in
repeated fields. This is consistent with protobuf semantics in
general, but many people don't know about this. For example, if you
have
var pb myproto.MyMessage
for 
and pb contains a repeated field, then every Unmarshal keeps appending
new values to that repeated field instead of replacing it entirely. Or
if pb has an optional field present in the first iteration but missing
in the second iteration, the second use(&pb) will still see the field
from the first iteration. The safe way to reuse pb would be
var pb myproto.MyMessage
for 
Since most people are unaware of this property of Unmarshal, most code
reusing messages does not call Reset, leading to memory leaks and
incorrect behavior. To address this, I am changing Unmarshal to call
Reset before doing the actual unmarshalling.
If you knew that Unmarshal behaved this way and wrote code depending
on the 'append' semantics, please change that code to use
proto.UnmarshalAppend.
Thanks,
Dave.
The problem with this approach is that if the C code retain this pointer,
Go's GC won't
see it, and might garbage collect it.
Of course, if you're sure C code won't keep the pointer, this approach
works fine.
I may be missing the point, so I apologize if I'm being dense. But I think
the cleanest way to do this is:
(My example code was getting a little long). It's possible to use malloc
and cast to a go pointer, and unsafe.Sizeof can help determine the size of
a structure. But by far the easiest way to do this imo is
by letting go allocate all the structures, c or otherwise.
I respectfully suggest you're over-thinking it. Take advantage of go's
awesomeness and just treat it like a normal struct.
a := &C.struct_student
sizeof is an operator, not a function. I don't think you can use
directly like that in go. You can use
C.size_t(unsafe.Sizeof(C.struct_student))
<robert.s...@gmail.com> wrote:
-- 
matt kane's brain
Try it and see. I don't think GC will collect this memory.
<robert.s...@gmail.com> wrote:
-- 
matt kane's brain
<robert.s...@gmail.com>wrote:
Not that I know of.  Usually it wouldn't make sense, since the point of cgo
is interoperability with existing code, and that would imply that you're
writing C to interoperate with existing Go...
What does gdb say?
jsing has committed a fix today. hg pull -u to get the update.
Yeah, that. Sorry I didn't say so in the first place. 
kr 
Connect the dots for me.
What does making it public accomplish?  Can't you just return that error
message/code on your own?
Just guessing -- it's to "catch" that error, not return it:
if err == http.RequestBodyTooLarge  else 
I'm using http.MaxBytesReader and I'd like to return
either status 413 or status 500 to the client, depending
on whether the limit was reached or some other error
happened.
How about making errors.New("http: request body too large")
into a public variable of package http?
kr
Hi all,
I build gdb 7.3 with python support for Windows 32bit and 64bit,
for python2.6 amd64,
for python 2.7 x86. and works runtime-gdb.py
gdb for windows crash on auto load scripts, and source command also
crash, I don't have time to digg into it, so need disable auto load
scripts for make runtime-gdb.py work. put runtime-gdb.py and create a
.gdbinit file in want debug program's folder, content as:
set auto-load-scripts off
python execfile("runtime-gdb.py")
enjoy.
--
Wei guangjing
Oops.. the wonders of copy & paste. Fixed, thanks.
-- 
Gustavo Niemeyer
-- I'm not absolutely sure of anything.
Hey all,
In case you're using the Bazaar VCS, you've likely stumbled onto
problems while trying to make the usual workflow work with $GOPATH and
the new go tool.
-- 
Gustavo Niemeyer
-- I'm not absolutely sure of anything.
OpenMail.co is hiring Go engineers in Venice, CA, just half a block from
the beach. You must be based in the Los Angeles area or be willing to move
here (we'll fly you out for an interview and pay relocation expenses).
0) We're solving fundamentally interesting problems related to discovery
and communication.
1) The technical team is still very small (2 distributed eng, myself in LA,
and all future hiring in LA).
2) Our financials are extraordinary for a company of our age/size ($20M+
revenue, very strong margins).
3) You will write Go every day.
-John Fries
jfr...@openmail.co
Hi guys,
We're on the hunt for some Go engineers in the San Francisco bay area (yes,
must be local for this unfortunately), please let me know if you're
interested.
Backend Engineer (Go)
San Francisco, CA
Join one of the leading Go companies in the world and help build next
generation, high-scale, high-performance cloud services. We're looking for
new Go developers to join the San Francisco team and work directly under
the CTO and Co-founder.
You will:
Write Go
Write more Go
Write a blog post about writing Go
Write Go
Help us organize GoSF – The worlds largest Go meetup
PS: Sorry for the spam. Unless of course you are looking for a job and this
is not spam to you, then you're welcome. ;)
Travis
Thank you Ross, I'll try it...And if you have some code to show, I'd like to see it :)
These functions usually return multiple values, the last one is the error (not nil if error happened). Check it!
Assuming a normal MIME multipart response, this should be a matter of
parsing the Content-Type header to find the boundary and passing it to
NewReader in the mime/multipart package.
(I have used Go to do exactly this to pipe the images into OpenCV.)
Ross Light | Software Engineer | li...@google.com
Hi, 
I managed to get the stream byte by byte ad it comes but I still have some missing pieces. I don't get how to use reader.NextPart(), or I don't now how to correctly  build multipart.NewReader. I always get errors like "multiple-value in single value context"
Any clues?
Thanks
Teo
The compilation error is because Connect wants a pointer. Do this instead… 
sa := &unix.SockaddrInet4
Michael Jones
michae...@gmail.com
Oh, I can successfully compiled my code both on Darwin and Linux.  Thank
you!
--
KINOSHITA Minoru
kinoshita...@gmail.com
2016年6月28日(火) 1:17 Michael Jones <michae...@gmail.com>:
There is no escape rune in the csv package, internal or otherwise.  There
is only quoting, doubling the quote to get a quote in a value.  The only
special characters are:
The separator (defaults to ')
The quote (")
The lead comment character (defaults to none)
The newline character (\n)
The carriage return character (\r)
Whitespace (unicode.IsSpace)
My point with the ability to use ' and " at the same time was, where do you
draw the line, and why is that the line?  Quoting is most complicated part
of the csv reader.  As I said earlier, making the quote character
configurable is very easy (it changes 8 lines and adds 1 line + comment +
tests) and does not break backward compatibility.  The issue is where the
line is drawn for the standard library.  I do not draw that line.
Perhaps you should use the proposal process and propose the change, perhaps
along with the change itself since it is so easy.
    -Paul
There are too many different variants of CSV out there.  We can't
support them all without producing a horrible Frankenstein's monster
of a package.  You should just copy encoding/csv into your own source
code and adjust it for your needs.
Ian
It appears declaring what constitutes a quote isn't possible. I'm working
with data published by USDA which uses a tilde to quote fields and those
fields may contain actual quotes (', "). Enforcing a set number of fields
per record and setting LazyQuotes = true does appear to work at the surface
level (I haven't inspected the actual data), but is this really enough to
guarantee data is intact as intended?
Is declaring what constitutes a quote, same as csv.Reader.Comma is used,
desirable in csv package? In my case, it would be more clear.
Well it's another concern. One could continue with "... and what about NULL
values" but these are all independent concerns. I don't think that's a
slippery slope as the features are not necessarily interdependent but the
particular change in question does expose a wider variety formats supported
without creating a Frankenstein and fitting within the current framework.
If the concern is that more requests will pour in to support arbitrary
functionality that doesn't already fit well within the current work, and no
one is prepared to respond appropriately to those requests, then it sounds
as though csv probably shouldn't have made it into the std lib. Either way,
I give more credit to you, the author, in saying the change likely wont be
accepted, and that's ok.
After reading the RFC, it appears package csv already does more than what's
suggested within so there's not much of a case to be made here if that RFC
is the guiding principal.
As far as what the USDA data does, the behavior is such a circumstance
doesn't exist. Taken from the docs:
"ASCII files are delimited. All fields are separated by carets (^) and text
fields are surrounded by tildes (~). A double caret (^^) or two carets and
two tildes (~~) appear when a field is null or blank."
Somewhat related, I happened upon the tilde usage in this:
I suppose at this point I'll probably just opt for some sort of line
scanner.
I think it's clear by the silence that a value containing ~ is considered
invalid. These types of cases aren't complications as such a view on ~ is
only narrower to what might be done with a csv parser. In the future if
they decided ~this is~valid~^ as a single field then they should stop
naming their data dumps with csv extensions.
You could then write 'The "word" is' and "Don't do that"
No. A field is quoted by a given rune, so the categorization of a set of
runes (such as quote characters ' and " in writing) is irrelevant. I'm not
personally aware if this is even possible in csv parsers out there and I've
never seen data like this. Is that something to do with Excel again?
If anything, I think the next question would be why doesn't the csv package
allow setting the escape rune, another common setting.
It's just the de facto standard, for example:
perhaps along with the change itself since it is so easy.
I'll consider it, thanks.
The RFC was the guiding principle.  I can assure you of that.  Yes, the csv
package can handle more than that, in particular, the ability to have
variable number of fields per record, the ability to have comments, the
handling of white space.  All of these were relatively common situations.
 (The white space handling is because Excel removes all leading white
space.)
The USDA spec is silent about what to do if the data has a ~ in it, so it
is not clear what to do with a ~ that is not at the start or end of the
field.  I will note the USDA spec also uses a '^' as the delimiter.
The csv package can handle what you linked to,
to use a ~ instead of a , to separate fields in a record.
I agree that it would be quite easy to make the quote character settable,
but that would beg the question of why the csv package can't handle
different quoting mechanisms.   Should it be able to handle two different
quote characters, like ' and "?  You could then write 'The "word" is' and
"Don't do that", but I don't see modifying the csv package for that at this
point, at least, not doing that and getting it into the standard library.
    -Paul
I completely understand this point of view, there is no csv "spec".
But, down the rabbit hole, is it so much to suggest configurable quotes?
For example, this data was originally being imported directly into postgres
as-is by defining a delimiter and a quote character. While it's unfortunate
that the current API uses "Comma" to define field delimiter, there's still
nothing that appears prohibitive in also defining what a quote character is.
In this case, I only see benefit. The ad-hoc defining factor here is a
delimited field can be defined by a given rune that may contain the field
delimiter. Without too much thought given to the circumstance or an
in-depth review of the code, I'm fairly certain this doesn't introduce any
strange complex behavior. If it were too, that seems like something that
should be fixed regardless.
Thanks for your input Ian.
As the person who wrote package csv (and convinced Russ to include it), I
researched many CSV formats.   I don't believe I ever found any "standard"
that used anything other than a double quote for quoting.  Unlike the other
options, quoting is not as simple as the quote character.  The problem
comes when you have a quote character inside the value.  There are multiple
ways people do this, including (with spaces to make it easy to read): " ",
" " ", \ ", " ' " ' ".  The RFC says you escape by doubling the quote (the
first in that list).  Note that this means Go's quoting (%q) is not valid
for the CSV parser.  What does the USDA do for values that contain the ~
character?
Russ was not inclined to include package csv, mainly due to lack of
standard.  Russ agreed to let it in only when I was able to point to RFC
4180.
    -Paul
Reading that it means we you also add an Escape character and default it to
the Quote character.  This is the slippery slope, the question is where the
safety net is to stop you from sliding.  Ian has indicated we have already
hit the safety net.
    -Paul
<philipp....@gmail.com> wrote:
I don't know if there is a doc.
Compared to 1.0 the tip GC runs in parallel, so it is faster.  It has
much more accurate type information, so it much less prone to, e.g.,
treating a float value as a pointer.  It is possible that by the 1.1
release it will become fully precise; currently it is (I believe)
precise for heap values but not for stack values.
However, the 1.1 GC will remain a mark and sweep collector.  It will
not be incremental, nor generational, nor will it move values around.
It is clear that it will continue to be a good idea to use pools and
custom allocators for data structures that use a lot of memory.  Work
will continue on the GC after the 1.1 release.
Ian
i'm not sure that this would work well.
1) strings: two strings with equal contents are indistinguishable
even if they're located in two different parts of memory.
2) non-heap-allocated objects: some objects larger than 64 bits
are not allocated on the heap. does every value of type complex128
have a unique number? is this changed every time the value is copied?
and what happens when Go is changed to allow equality testing
on struct values? (i do hope this will happen some time...)
I wouldn't. I'd demand that things that want to be put into sets
satisfy a non-empty interface -- eg but without prejudice, hash
and equality methods.
Chris
-- 
Chris "allusive" Dollin
map[interface]bool
?
Russ
I do agree that int64 is a lot of space overhead ..
I don't agree with the "equal things, equal hashes" because what I am
proposing is not a hash. It is a number that distinguishes objects not values.
P
Demanding equality is reasonable, demanding hashing is not.
Hashing, i.e. numbering objects when this is not necessarily a part of their
natural mathematical meaning, is a convenience implementation thing which
the compiler should support. Here's why:
autoincrement counter,
but this is a drag for the programmer to do for every object. This
cannot be implemented
in transparently in the, say, set data structure library because the
only way this library
has for distinguishing objects is by pointers (if they were
unchanging). So the programmer
would have to use a custom method for this.
I propose that Go provides a method, called something like "ObjectId"
(or whatever)
which returns an int64 that is unique for every object in the system.
In the current
implementation, this could just be the pointer to this object. But if
later the Go
folks decide to implement a copying GC, they can change the language so that the
autoincrement counter is a part of every struct.
P
Thanks Russ. This will do.
Although, for you reference, there is a scenario which cannot be
captured by this suggestion:
Imagine you want to maintain membership in a product set of
objects (i.e. AxA). If the set is very sparse, the data structure
map[interface]map[interface]bool
will not do.
P
i wonder how much that would be complicated by the fact that
pointers can point into the middle of heap objects.
Could you not leave that until the next use of the map?
[That's what I did in a dynamic language implementation.
 But that probably relied on knowing that no other thread-
 like thing was going to get in the way and that GC couldn't
 happen while the accessor/updater was working on the
 map.]
Chris
-- 
Chris "allusive" Dollin
I don't see anywhere that the language specification explicitly
guarantees it, but at least for the current implementations it should
be safe to assume that pointers don't change.
I suppose it's possible that someone might write a copying garbage
collector at some point.
- Evan
Hi,
I'm contemplating using pointers to objects as hash codes (for
placement in
a hashtable). So, are these pointers guaranteed to stay unchanged
during the
life of an object?
Thanks,
--Petar
I have a feeling that this raises an issue with the language design.
If we agree that in every language you should be able to
implement a set membership data structure, whose entries
are interface, then the question simply stands:
How would you do it in Go, without resting on hopes that the
garbage collector won't move objects in the future, or for that matter
without
using the "unsafe" package anyway.
--Petar
I don't think that works very well -- it means there's an extra
overhead of an int64 for pretty much every struct, and a struct
with structs in it will have nested overheads.
Also equal things should have equal hashes, which the scheme
above doesn't satisfy.
Chris
-- 
Chris "allusive" Dollin
I don't see why this should be part of the language, just implement it
on types where you need it.
The current implementations do not move objects.
There's nothing in the language spec that prohibits it,
and a future implementation might move objects,
but if you're writing code today it's a reasonably safe bet
that the objects won't move.
Adding to what Ian said, updating pointers into the
middle of objects is easy.  A much more annoying
complication is having to rehash any map[*foo]bar.
Russ
roger peppe <rogp...@gmail.com> writes:
A copying garbage collector has to be able to reliably locate all
pointers.  Given that, adjusting pointers into the middle of objects is
not really any harder than adjusting pointers to the start of objects.
(I don't know of any current plans to actually implement a copying
garbage collector.)
Ian
in real code, i almost never panic in response to an
error return - i'll almost always handle it in some way.
so for real code, i don't this feature would carry its weight.
when writing quick little go programs, i'll usually have
a helper function, for instance:
   f, err := foo.Bar(x)
   check(err, "bar %q", x)
this way the error message comes with appropriate context
(it tells me what the value of x was when i called Bar)
and saves me seeing a large stack trace which is rarely
what i want in these situations - i just want the program to stop
when something goes wrong.
so i wouldn't want to use this feature even for throwaway programs.
If you are tired of reading feature proposals stop reading now. Else,
use fixed-width font for best reading experience.
Panicky Assigned Values
=======================
A “panicky assigned value” is a value assigned using either = or :=,
which causes the program to panic whenever the value is not nil. It
would generally be applied to errors returned by funcs. Unfortunately,
I could not find a way to cleanly implement this feature using current
Go syntax, thus the proposal.
Just like _ (blank identifier) allows you to indicate unused assigned
value, @ (panicky identifier) will allow you to indicate a panicky
value. More precisely, this line:
a, @ := somefunc()
Is equivalent to:
a, err := somefunc()
if err != nil 
The proposed syntax is concise, clean, explicit and useful in many
situations.
Motivation
==========
In this text “error” means an intermittent environmental error, such
as lost network connection, out of memory, or out of disk space. It
does not mean programmer error or a bug.
By convention errors are returned as the last return value of a
function. There are two things that a developer can do with an error,
ignore it or handle it.
This is how you ignore the error:
a, _ := somefunc()
This is how you handle the error:
a, err := somefunc()
if err != nil 
In practice, you rarely want to ignore an error. Most often you want
your program to handle the error. The three popular choices are: halt
the program (or at least the routine/request handler), pass the error
up the stack to the caller, and finally recover from the error (e.g.
renew the network connection and try again). In more complex cases it
can be some combination of the three.
In a complex fast-paced release-early-release-often software
development environment, e.g. web apps, it is common to start with the
halt-the-program reaction to intermittent errors, and as the project
matures you gradually add proper error handling to make it more
robust. By then you gain knowledge about your system, including which
errors should be handled and how. In the beginning though, halting on
error is a safe lazy choice. A non-robust program can still be useful
and can be good enough in the early stages, when the team is small and
the features and algorithm correctness are more important than
robustness/performance/etc. You don’t want to get stuck in premature
optimization, or I should say premature productization.
More importantly, in many cases halting the program on certain errors
_is_ the desired behavior. In these cases an “if” statement for each
error is just noise.
Unfortunately, the most concise, the laziest, the most release-early-
release-often-friendly syntax is available only for ignoring errors,
which is never a safe choice even for early-stage projects. This
motivated me to come up with a similarly easy syntax for halting
programs when errors are detected. Without it developers are
incentivized to ignore errors, waste their time on premature
productization and/or pollute their code with boilerplate.
Looking through the mailing list you can see that dropping errors (_)
instead of handling them seems to be one of the most common mistakes
people make. To my mind, providing some implicit panic is not less
harmful. It would most probably be used as the standard handling for
errors... people stop actually thinking about possible errors because
they are not gonna handle them anyway. This will result in programs
that panic every tiny error, even if it could be handled in a clean
way.
I am sure that your idea might be useful for people who know how to
deal with it (as you described... early stages only and so on). But
people do not know or do not want to know because they are to lazy at
the moment, they want to add correct error handling later, later is
never going to happen, and so we end up with a bunch of constantly
panicing programs.
For the early stages of development some simple script that does some
search&replace could do what you are suggesting without affecting the
language itself.
2011/12/8 Peter Bourgon <peterb...@gmail.com>:
As has been pointed out, there are ways of concisely declaring that a
non-nil error will panic.  Whether you go the more verbose route proposed
above or a simple chk(os.Error) function is up to you.  As you say, Go is a
tool, and you can use it however you wish.
And for developing features quickly and iterating rapidly?  I find error
checking *absolutely essential* for these tasks.  While I may not return an
error when I find it, I will always at least print it out or fire it off at
our monitoring solution.  This short circuits a lot of debugging when I see
when something might cause an error later and the fact that it doesn't
panic allows it to continue on with whatever else it was doing without
completely falling over and requiring a code change to proceed.
Yegor wrote:
Panic eventually gets replaced by actual error handling. The same
conditional branches on error in both cases.  When you replace panic
with proper error handling the branching code will be written
eventually, so why not do it in the first place? Why use a mechanism
only to replace it with something else afterwards?
Checking for errors is explicit and feels natural, even to programmers
not familiar with Go, your proposal proposes something that is
explicit in the sense that the programmer must express intent, but is
cryptic and incomprehensible for a programmer not familiar with the
language or with the feature. While the code is shorter, I feel it
weights more on the page.
In those cases, I think the conditional is not noise, but the best
thing you can do. If you want to panic, panic, it's your decision, not
compiler's. Don't hide it inside some cryptic statement, make it clear
and visible to the reader.
-- 
Aram Hăvărneanu
Just to clarify, according to the proposal:
I find it quite explicit. You know before you run your program how it
will behave. The problem with implicits is compile-time ambiguity,
e.g. in some languages when you mistakenly add a float to an int the
compiler automatically performs type conversions instead of failing
compilation.
I would much rather train people to handle errors properly than to simply
panic for everything.  That sounds like exceptions to me.  If that takes
them getting bitten a few times when they ignore error returns, then I
think it's an overall win.
~K
Yegor wrote:
Of course, but you mentioned that people panic in prototype code and
replace the code with proper error handling later.  I was responding
in that context.
Typing that extra two lines of code does not take much time.  In my
experience I spend significant less time typing code compared to other
programming tasks like thinking things through, reading code,
analyzing how code works, debugging, etc.
Even if you don't know what _ is you can still read code that uses it
and understand it.  On the other hand @ has side effects that the
reader need to be aware of.
In my experience, if people want to ignore errors, no language feature
will stop them.  Too many people add catch all clauses in Java to stop
the program crashing, even though the catch all does not do anything.
The syntax to ignore errors exists today.  If some people chose to
abuse it, your feature won't stop them.
In my opinion, the least context a reader needs to understand
something, the better.  The code should tell the reader exactly what
it does.  I am not a fan of syntactic shortcuts and magic language
features.
Every syntactic idiom in a language burdens a great weight on the
shoulders of the reader.  It is always a trade off between
expressiveness, utility and clarity.  I feel Go makes this trade off
better than every other language I have worked with.  I feel that
adding alternative syntax without adding expressiveness would tip the
balance Go strives for.
Because Go code is straightforward, explicit, and lacks syntactic
sugar reading and answering these questions is easy.
Then don't panic and make your code clearer.  I believe error handling
is part of the algorithm, and that you can have very clear code even
if you do proper error handling.  I think you can write error handling
without sacrificing the readability of your code.
Go is more concise than most languages used in the industry today.  I
disagree that _ promotes error ignorance, but even if that's the case,
@ doesn't change that.  People can still abuse _ if they are so
inclined.
Conciseness is not a virtue, clarity is.  They are related, but it's
not a linear relationship.  I think Go succeeds to maximize clarity.
-- 
Aram Hăvărneanu
Or just write Go in the standard style and see if it grows on you. If
after writing a few thousand lines of code you still find it
unbearable, come back to this.
Dave.
You've mentioned two problems you have with the language:
1. It's tedious to write error-handling code.
2. It's too easy to ignore errors.
I happen to agree. I think both of those things are flaws with the
language.
My fantastized solution to #1 is a must() built-in. If f is a function
whose last return type is error, then must(f(...)) panics if that
error is non-nil, else it returns the other return values, omitting
the error. E.g. instead of
n, err := w.Write(bytes)
if err != nil 
one could write
n := must(w.Write(bytes))
I don't think we'll ever have that built-in, but someday someone will
write a smart enough macro system for Go (it would have to understand
types), and then you could write must() yourself.
Anyway, thinking about must() at least lets us separate the semantics
of your proposal from the syntax, since must() has the syntax (and the
semantics!) of an ordinary call. You can't write it in Go solely for
type reasons.
I should add that I personally would only use must() for initial
prototyping, pedagogical code (I hate "this code omits error checking
for clarity") or in those rare cases where panicking is really the
right thing to do. I believe that most of the time it isn't.
For #2, namely the problem that's it too easy to write
f(x)
when f returns an error, I again have a language-y solution and a tool-
y fallback. I wish there was a way to annotate a function return value
so that it would be a compiler error for the caller to ignore it. Gnu C
++ has something like this as an extension, and I happen to like it.
Callers could still ignore errors if they wished, by writing
_ = f(x)
but they'd have to go out of their way. Note that the proposal is not
"a return value of type error must never be ignored," because some non-
error return values might be important to check, and some error return
values might not be.
Since that's never going to get in the language (the discussion has
been had), the fallback is to have a tool, like govet, find these
situations and warn about them.
TL;DR with suitable tooling (NYI), Go can have the error-handling
behavior that you want.
I've just realized that my solution sucks big time. I kept assuming
that the returned values are always assigned. What if they are not? A
demo:
a, _ := foo()
a, @ := foo()
I'll have to start over.
Yegor
Not true. There are tons of wonderful Java and C++ programs out there
that may not be 100% robust (if that's possible at all) but they don't
"constantly panic". You see, you can create great programs even in
languages that suck.
Ignoring errors is a bad idea, even at the early stages of your
project. A compiler warning is not enough.
$ cat `find | grep .go$` | wc -l
1806
and in another folder
495
So 2301 lines so far. A lot of it is just tinkering: solutions to
projecteuler.net problems, simple algorithms and one small app-engine
app. So far I love everything about Go, except error handling. I don't
think it's safe. I know, there are tutorials, blogs and discussions
filled with information about Go error handling. But the huge amount
of information on this topic only indicates that there is a problem.
I am an app developer. A lot of advice seems to come from systems
people, and Go did start as a systems programming language. The app
programming world is a little different, which might explain why this
advice isn't very convincing to me. With apps you deal with business
people, deadlines and ambiguity. The development process is structured
differently. You have to sacrifice robustness and performance before
you even know what your app is supposed to do, all while your app is
in production. So I need a safe error handling mechanism.
I am still optimistic that there is a solution that suits both use-
cases: the rigorous systems programmers and the lazy distracted app
developers like myself. After all Go on App Engine is going to be used
for apps, not systems.
Yegor
Who are you quoting? I reread my proposal, and I could not find the
word "implicit" in it. I am proposing the exact opposite, an
_explicit_ panicky identifier.
that's the kind of thing that could be added to govet if desired.
although it would be annoying to see all those ignored errors
from fmt.Printf, x.Close(), etc.
From past conversations I believe the consensus is that panic is
appropriate for programming/technical errors while error is for everything
else.
christoff...@forsvikgroup.com> wrote:
wrote:
A common enough experience with Java and C++ programs ;)
What the OP actually wants is a kind of assert statement/builtin
function.
What _could_ be useful is a compiler warning that tells you where you
have been ignoring errors. That can be easily converted into a compile
error for the paranoid. (Although knowing if an ignored second value
is actually an error is not so simple.)
steve d.
This is because you choose to follow a different software development
process, which by far isn't the only one.
Quick little Go programs or throwaway programs are not what this
proposal is targeting. On the contrary, it is targeting large complex
projects where nothing is final for a while, so you don't want to
waste your time on things like proper error handling in a component
that may not even make it into the final product, but at the same time
you don't want to blindly ignore errors. When you are writing a web-
app, your first priority is to make it useful, not 99.99% SLA. It can
actually gain a decent user base even with occasional glitches, as
long as you are not corrupting user data. First come features, then
come robustness and performance.
I'm not quoting anyone, rather coining a phrase. For me, explicit
panic means you explicitly call the panic builtin.
  if val, err := foo(bar); err != nil 
Whereas "implicit" panic means a panic may be triggered as a side
effect of some (any) other action,
I prefer the first to the second. But I think you make a reasonable-enough case.
I'm not seeing the problem. Maybe it's a lack of sophistication of my code.
In my simple interpreter, I have lots of little leaf functions that
operate on a stack. The exported function is Eval. The internal
functions do stuff like this:
 x := toInt(stack)
 y := toInt(stack)
Bad things happen, of course, if the stack is empty or the top of
stack value can't be turned into a number.
Now, in an earlier form, that code was awful:
 tos, err := stack.pop()
if err 
i, err := strconv.Atoi(tos)
if err 
Yuck! But then another couple go talks (Andrew's and Rob's) once again
changed my life.
So I put a recover in Eval, following the example from Andrew's nice
talk, and only two functions (pop and toInt) do panic, and I end up
with code like this:
Now, this may still not be perfect, but the rules I took away were simple:
- one or two internal functions that panic
- other functions that don't panic, and don't do all the if err != nil
tests, but *use* those internal functions which will panic if needed
- the exported function recovers and returns an Error
and it has worked well for me.
But, again, maybe my experience to date does not encompass complex
enough situations.
Error handling is always the worst part of anything I've ever written.
I think it's good that Go forces people to code for it and really
think about it. Just my $.02.
ron
<christoff...@forsvikgroup.com> wrote:
Not perhaps as concise as you'd wish, but grepping for "panic"
in $GOROOT/src/pkg/*/*.go will give you a good range of examples.
As for idiomatic use of recover, the go/printer and encoding/json packages
both use panic and recover to simplify their error handling.
(the panic and recover code there should be relatively straightforward
to understand without needing to grok the entire package source)
Not exactly, in many cases you just want to panic.
Because of project priorities. You want features first, 99.99% SLA
second. And in those cases where you simply want to panic, you won't
replace it at all.
That's the nature of learning a new language. Go already has plenty of
features that feel pretty alien to newcomers. Plus, there's not much
difference between these two lines in terms of readability:
a, _ := foo(bar)
a, @ := foo(bar)
It's just that the second line is a safer choice when the second
return value happens to be an error. You don't want to incentivize
newcomers from other languages to ignore errors by giving them a
convenient syntax to do so.
The primary objective and the most frequently traveled path of any
This is why for any reader of the function's code the first question
is "How does the function produce the correct result in the absence of
errors?" The second question is "How does the function behave when an
error occurs?", and is only important after the reader got their
answer to the first question. If your algorithm is hidden between
multiple blocks of error handling code that just panics, you make it
harder for the reader to understand your code. Explicit and concise is
what makes your code "clear and visible". The current approach is
"explicit and verbose" and promotes error ignorance. If Go's target is
to "feel like a dynamically typed language", conciseness is one trait
it must strive for. If it's goal is to discourage error ignorance it
should provide syntax that competes with ignoring errors.
Several problems with this approach:
- Such a function would have to be built-in or in the standard lib,
otherwise you end-up everyone implementing their own version
- The syntax is still fairly dirty:
a, err := Func1()
MaybePanic(err)
b, err := Func2()
MaybePanic(err)
c, err := Func3()
MaybePanic(err)
- The stack trace points to the wrong line in the code
- Not official, so people are not aware of this option
The Must* convention is for use in initializing global variables, usually.
 It's often best to use the non-Must* variants in code.
I usually design my programs so that errors travel through the stack
to that point of origin where I handle them. It is quite rarely that I
actually use the panic/recover mechanism.
For the sake of this discussion, can anyone give a good and concise
use case of panic? (and maybe recover too)
That is a major motivator for this proposal.
You are the second person to label it as "implicit". Please explain
what is implicit about it.
I disagree. People do go back and fix programs that crash after
identifying the reason for the crash and coming up with the solution.
I have not seen many programs that "constantly panic". A lot of
programs, even those hacked up in a weekend, run ok.
Yes, but ignoring errors even at the early stage is not an option, as
you may be corrupting data and making your program extremely hard to
debug because the program crashes way after the ignored error maybe
even in another part of the system.
Do you think it is a good idea for any program to "implicitly panic",
that is, panic without explicitly calling panic()? This seems to me to
be quite a lot of magic under the covers, and requires quite some
serious justification.
i won't comment on the  usefulness of this or whether or not it's a good idea... but  unless i misunderstood i don't think you need any special syntax for tjis. just write a function that  takes an error and does what it will. 
1. A programming language is just a tool. When you say you want to
train people that's a big red flag against wide adoption. A successful
programming language should be adaptable to different development
processes.
2. "to handle errors properly" in many cases is to panic
I do not suggest that you panic for _everything_. I suggest that it's
more often better to panic than to ignore an error.
Unfortunately corrupted data and hard to debug code doesn't always
bite the original author of the code, but also the users and other
people in your company.
Аspects of the problem:
- The convention in the Go libraries is that even when a package uses
panic internally, its external API still presents explicit error
- panic means "everything goes wrong". The sense of what is wrong
depends on a context. Cases of a library and an end-user app are
different.
- "if e != nil " and "if e != nil " occur too
often
- _ exists to omit a result value variable. The use of _ is harmful.
I.e. f, _ := os.Open("name"). f is nil, nil-pointer panic occurs. why?
- Making the error handling too special leads to the exceptions in
Java or C++. But os.Error have become error. And error tends to be the
last result value.
In my experience I also think that some short way to panic if error is
not nil would be convenient.
Let's consider API (or look at mysql or redis libraries in Go)
- db.OpenDb(name string) (*Db, error)
- db.(*Db).Get(key []byte) ([]byte, error)
- db.(*Db).Exists(key []byte) (bool, error)
- db.(*Db).Put(key, value []byte) error
error can be out-ouf-memory, out-out-diskspace, network problem
And app that handles http requests and manipulates some databases.
Aspects:
- db API should definitely return error. See the first aspect.
- I can check OpenDb's error once. But checking of Get, Exists and Put
leads to endless "if e != nil " or "if e != nil "
- "if e != nil " is really sensible in this context since
these errors means "everything goes wrong".
Possible solution:
- Make a wrapper in a package of application: MustGet(key []byte)
[]byte, MustExists(key []byte) bool, MustPut(key, value []byte)
- Some other approaches? Am I wrong? Inconveniences does not exist? Or
they are insignificant?
Hi,
I released jsondoc a command line tool used to simplify creation of
documentation of HTTP (REST) JSON APIs for projects written in Go. The
input and/or output JSON structure for particular endpoints is obtained
from named types from selected Go packages. The output of jsondoc is an
HTML file with embedded CSS.
Example output:
Repo and description:
Regards,
Łukasz Pankowski
I have a package that provides a
that may do what you want.
Cool. Can build now. Have testing error, will take a look later.
You're probably using an older version of Go, back from when it was at
"exec", instead of "os/exec".
You didn't say which version of Go, though.
It'll be a lot of work changing go-fuse.  Just roll back to an earlier
version of go-fuse (perhaps there are tags for r60), or move your Go
version up to a latest weekly.
$ 6g -V
6g version release.r60.3 9516
Let me try to change code in go-fuse.
Hi there,
Below is what I faced. Any ideas?
$ env | grep GO
GOBIN=/home/xiaofengguo/code/hg/go/bin
GOARCH=amd64
GOROOT=/home/xiaofengguo/code/hg/go
GOOS=linux
GOPATH=/home/xiaofengguo/code/hg/go
$ 6g mount.go
mount.go:7: can't find import: os/exec
Best Regards,
Xiaofeng
Everything in exp is experimental and even less committed to
than the rest of the "standard" distribution.  Iterating over data
structures using channels can be powerful but is not as cheap
as a simple for loop.  Most Go code does not use this idiom
unless there is a redeeming reason (like it makes the code a
lot easier to write).
Russ
tiny_dust <ustc....@gmail.com> writes:
References are equivalent to pointers except that they introduce an
implicit & operation and you can't have pointers to pointers.  Neither
change seems desirable to me.  Nobody is forcing you to use pointers,
but they are a useful construct in a language like Go which gives you
control over the memory layout of your data.
No, we can't, at least not without other changes.  An expression
statement may start with "struct"
	struct  
and a block statement may start with "

There was effort on Go NaCl support at one point, which is similar to what
you're suggesting.  Have you taken a look at Dart?  To me, it seems a much
more suitable replacement for JavaScript than Go does.
I just was thinking about to use Go directly from the browser,
independently of having a compiler from Go to JavaScript.
At the first, my idea was to build a VM for Go. But it isn't really
necessary since there are tools to run Go code like if were scripts.
I think that to run Go code from our brwsers would be "as easy" like
(1) to install the Go toolchain (command go) together to its compiled
libraries (about 45 MB) --except some libraries or functions which
could be unsafe like functions in package "os" or library "unsafe"--.
(2) And of course, the browser should be allowed to use the Go
toolchain; this is the key point. Does anybody with experience in
browsers could say me if it's possible?
Advantages:
+ One same specification so our code doesn't breaks in different
browsers. This is a great problem in JS (thanks Microsoft)
+ One only language for all development, and all advantages of Go
+ The third libraries could be cached so it would speed up the web
applications.
And in a short time, I'll can use a language with a clean sintaxis and
non-verbose like Go for the client-side although the way to get it is
compiling Go to JS, by now.
as Java for the client-side if I can choose.
NaCl is different to my proposal since NaCl was built to run native
code in the web so code already compiled; (which I think that it would
be very bad since we would get a "dark web" where you cann't know what
is going to do the NaCl program). My proposal is about compile Go
programs from the browser.
NaCl does a sandox to avoid to access to some system calls. But it
isn't necessary from a Go program because it cann't access directly to
the system calls; it would be as easy like avoid the calling of C
libraries from Go code.
Hello. Now bitbucket officially provide git repo hosting, if i want to
install package from bitbucket git repo, what i need to do?
goinstall not able to fetch git repos, becouse it thinks, that bitbucket
contains only mercurial repos.
-- 
Vasiliy Tolstov,
Clodo.ru
e-mail: v.to...@selfip.ru
jabber: va...@selfip.ru
I've submitted a CL to add support: 
-- 
Julian
2011/10/26 Julian Phillips <jul...@quantumfyre.co.uk>
Thanks!
-- 
Vasiliy Tolstov,
Clodo.ru
e-mail: v.to...@selfip.ru
jabber: va...@selfip.ru
I think you'll have to use the explicit goinstall form:
2011/10/25 Dmitry Chestnykh <dch...@gmail.com>
Can it possible to fix that in next release ?:)
-- 
Vasiliy Tolstov,
Clodo.ru
e-mail: v.to...@selfip.ru
jabber: va...@selfip.ru
Forgot to reference this:
-- 
Aram Hăvărneanu
golang Google search are much better to find golang related results
than it was on 2009.
go get is embraced and most of the active projects uses it. Maybe you
reached project that isn't very active or the project simply requires
too much custom build steps to be "go gettable"
go-webkit/WKA: Those are wrappers around webkit engine. go-webkit uses
the go-gtk bindings and gtkwebkit.
go-gtk: bindings for GTK 2. This binding is really good
go-uik: this is a user interface toolkit in pure Go, it uses go-wde
for rasterization and event capturing, but this project is only
starting so don't expect any great collection of widgets.
go-wde: low level API for rendering things and capturing events, this
one requires CGO
-- 
André Moraes
John Asmuth's go.wde and go.uik would be ideal choices for creating the
graphics part of sam.
-- 
Aram Hăvărneanu
Haha, I suppose I don't know enough about SAM.
There is no multi-line text area widget, yet...
Yes, that's why I explicitly answered it's good for implementing the
graphics part of sam. It might not be good for everyone and everything, but it's
certainly good enough for sam.
-- 
Aram Hăvărneanu
It looks like cmd.Start does that:
(Just don't use the Wait().)
You can tell them your application depends on Chrome being installed
and fire an external process from your Go app pointing the browser to
localhost.
Not sure that would be required, you can just tweak the CEF example
application in minor ways to run the go executable -- have them
communicate however you want (zeromq, websockets).  As long as you can
build an installer to put them in the same place, should be golden.
-- 
Robert Melton
AFAIK, node-webkit have versions for windows/macos/linux.
The look and feel of the window is native, you can't tell the
diference between a node-webkit window and a win32 window.
I think you could be able to set the size of the window without any
problems, but you should check node-webkit docs to be sure.
The renderer is the same, so, if you can use chrome you should be able
to use node-webkit.
-- 
André Moraes
2013/8/9 bronze man <bronz...@gmail.com>
How I do it:
create a simple html page using node-webkit (this project combines
chromiun source code with nodejs)
After that html page is loaded, I use nodejs stdlibrary to fire my go
application and create a websocket to do I/O.
Everything else is done inside Go.
-- 
André Moraes
Yes. fmt.Fprint will interpret %-verbs in the string, so if you might
have %-characters in that string, beware.
[I assume your question was more general than just for the specific
 string "str".]
Chris
-- 
Chris "allusive" Dollin
No. Fprint does not use format strings, Fprintf does.
--Benny.
-- 
The first essential in chemistry is that you should perform practical
work and conduct experiments, for he who performs not practical work
nor makes experiments will never attain the least degree of mastery.
        -- Abu Musa Jabir ibn Hayyan (721-815)
(fx:peers-closely)
Dagnabbit. So it isn't.
Thanks for catching it.
Chris
-- 
Chris "allusive" Dollin
Is there any difference between to use `fmt.Fprint(os.Stdout, "str")`
and `os.Stdout.Write([]byte("str"))` ?
I'm using now `os.Stdout.Write` to write ANSI terminal escape controls.
If all you want to do is output specific byte strings (and not do any
string formatting) you can just write straight to os.Stdout. fmt will
do the same thing eventually, so if you don't need any of its
functionality you might as well skip it.
Andrew
Fprint can print any data type, while Stdout.Write only prints byte
slices.
-Daniel
Hi,
I've released a tool to manage machine images from multiple providers:
It's still very alpha and I'm developing it but I think it's good to
go. Any feedback and contribution is welcome.
Regards
-- 
Fatih Arslan
Sorry, I only needed to cast the variable:
   memoryBlock[2] = byte(256 - (187 - int(memoryBlock[2])))
So since you're assigning to a byte I think Go is treating all of the
constants as bytes.  A byte can only encode between 0 and 255. You need
an extra bit (ie, more than a byte) to store 256.   Something like the
following works but might be silly:
 memoryBlock[2] = byte(int(256) - (187 - int(memoryBlock[2])))
vase <v.to...@selfip.ru> writes:
Go does not currently support loading shared libraries.
Ian
Hello. I'm try to learn go language, now i have C daemon, that listens
sock for json requests.
All request served by C shared libraries, that dinamyc loaded at
runtime (listed in config file). After daemon recieves reuests it
passes it to module and waiting for response, after that serves it to
client.
I'm not able re find any threads about ability to run module from go
language.
How can i extent base daemon functions using modules in case of use
Go? Is that possible?
If not - what i need to to in my case?
Finally i want to have 1 daemon, that able to use modules. If i need
new functions in my daemon - i get module and discribe commands that
it serves...
P.S. If i want to write support for specific protocol (in my case -
xenstore, used in Xen domU). What i need to do?
Thank You for all suggestions..
Go doesn't support dynamic loading of Go code into the same process space.
Here are a few different ideas to achieve what you want:
1) Use the standard rpc and gob modules to talk to an external Go
process over a well defined API.
2) Define a simple protocol and implement it through unix sockets, or
even stdin/out between processes.  This has the advantage that plugins
can be in any language.
3) Embed a dynamic language in your project.  Lua is a good candidate,
for instance.
There are other ways, but this should serve to inspire you.
-- 
Gustavo Niemeyer
-- I never filed a patent.
Can't it be done with cgo and then loading libraries from C?
the usual solution to this is to close the channel and then wait for
the thing at the other end to signal that it's finished.
for that, sync.WaitGroup can be a nice solution.
Gustavo Niemeyer's tomb package (see
can also provide a useful structure in this kind of situation, particularly
if you want to retrieve errors.
I've come across this situation a few times while writing go applications
and I was wondering what the best way to handle it is.
Say you have a package for sending email that has a buffered channel and a
goroutine processing the channel and sending the email.
Then in your application, to send an email, you put the data on the channel
and it gets sent asynchronously.
If your application exits before the goroutine has a chance to process all
the elements in the channel, some emails never gets sent.
So what is the best way to handle this?
My guess would be to call a shutdown function in the email package before
exiting the application (either via trapping the quit/interrupt signals or
calling it before exiting main()).  In the shutdown function, close the
channel then wait for the channel to become empty.
But I imagine there is an elegant solution that I don't know about.  Any
tips would be much appreciated.
Thanks,
Tom
We know about the problem.  Unfortunately, Google Groups is a
large target.  It's very hard to do the job perfectly.  I am sure that
far more spam is being rejected than getting through.
Russ
Spam from this mailing-list is of annoyance to the subscriber. Please
look into the issue.
S.
You are correct. gomake uses make, so you need mingw. You could run all compile and link commands (8g and 8l) by hand or put them in a batch file, but that is too verbose and sometimes complicated.
I hope, it will change soon. I believe, goinstall is getting rewritten at this moment, so it can be used as replacement for gomake.
Alex
How do you build packages by hand (gomake don't work) in windows ?
Hi All,
I am developing a JSON REST API server.
Currently i use one struct to save the resource and also to receive the 
REST request. And now considering to use separate struct to receive the 
request.
Let me give simplified example:
Id, CreatedAt, and UpdatedAt should not be generated by the system, not 
by external input.
So, i need to check if client defining above values in (e.g.) POST and 
then strip it.
That's why i created another struct to handle the request.
By using another struct to handle request, i don't need to strip Id, 
CreatedAt, and UpdatedAt at the POST/PUT request.
But using another struct will create some maintainability issue, where i 
need to make sure that ResRequest also updated (when needed) when there 
is update to Res.
By using one struct, receiving request and saving it to DB become very 
simple (I use gorm ).
It is something like this:
  var r Res
  json.Unmarshal(b, &r)
  db.Save(r)
  WriteHeader(201)
  writeJson(&r)
Which method that you think more idiomatic and better in Go point of view?
Thanks
also,
-brad
Also, change "Imports" to "Deps" to get all recursive dependencies
DEPS=$(go list -f $',')
-- 
Fatih Arslan
From go test -help:
    -coverpkg pkg1,pkg2,pkg3
        Apply coverage analysis in each test to the given list of
packages. The default is for each test to analyze only the package being
tested. Packages are specified as import paths.
E.g. in the directory for package A, run "go test -coverpkg A,B,C".
    -Chris K
Is there any way to automatically include the dependent packages ? I don't
see that mentioned in the help.
DEPS=$(go list -f $',')
go test -coverpkg=$DEPS
This will include all your imports. The output will be like:
PASS
coverage: 19.5% of statements in errors, fmt, reflect, strings,
ok  	github.com/fatih/structs	0.008s
-- 
Fatih Arslan
If all you're trying to do is get coverage of all your subpackages for a CI
and aren't concerned about downstream packages or manually toggling which
ones are one/off at runtime, I've used this script:
with Travis, and it seems to work fine.
-- 
- Dave
Thanks, it was very helpful. I am trying to modify it to output only a set
of packages starting with some prefix. Hopefully i'll get it done soon :)
Thanks once again.
Done, if you add an encoding/json benchmark with the same input then autobench will pick that up automatically. 
Thanks, Ugorji. This library is indeed awesome!
-- 
DISCLAIMER:
This is not an investment recommendation or a solicitation to become an 
investor of the firm. Unless indicated, these views are the author's and 
may differ from those of the firm or others in the firm. We do not 
represent this is accurate or complete and we may not update this. Past 
performance is not indicative of future returns. For additional information 
and important disclosures, contact me at this email address. You should not 
use email to request or authorize the investment in any security or 
instrument, or to effect any other transactions. We cannot guarantee that 
any such requests received via email will be processed in a timely manner. 
This communication is solely for the addressee(s) and may contain 
confidential information. We do not waive confidentiality by 
mistransmission. Contact me if you do not wish to receive these 
communications.
Robert-
Let me know how it works for you. Test coverage is about 80% but I'm going to bump that up soon. It's only about 1200 LOC so it shouldn't be too hard to grok. Let me know if you have any questions.
Bug reports and pull requests are always welcome. :)
Ben
Alberto, sorry to necro this thread, but: do you still plan to release this 
optimized JSON library?
wrote:
-- 
DISCLAIMER:
This is not an investment recommendation or a solicitation to become an 
investor of the firm. Unless indicated, these views are the author's and 
may differ from those of the firm or others in the firm. We do not 
represent this is accurate or complete and we may not update this. Past 
performance is not indicative of future returns. For additional information 
and important disclosures, contact me at this email address. You should not 
use email to request or authorize the investment in any security or 
instrument, or to effect any other transactions. We cannot guarantee that 
any such requests received via email will be processed in a timely manner. 
This communication is solely for the addressee(s) and may contain 
confidential information. We do not waive confidentiality by 
mistransmission. Contact me if you do not wish to receive these 
communications.
Hi Ben,
With your permission I'd like to add megajson to my autobench harness [1]
Here is some raw data comparing megajson running on 1.1.2 vs 1.2rc3
#megajson
benchmark               old ns/op    new ns/op    delta
BenchmarkCodeEncoder     20810857     15047966  -27.69%
BenchmarkCodeDecoder     75351857     54290820  -27.95%
benchmark                old MB/s     new MB/s  speedup
BenchmarkCodeEncoder        93.24       128.95    1.38x
BenchmarkCodeDecoder        25.75        35.74    1.39x
hey Dave-
That'd be great if you could add it to autobench. It'll be interesting to see how raw code vs encoding/json's reflection-based approach improve over time.
Thanks!
Ben
Ben--
Thanks!
This is very timely, we were just considering starting work on a very
similar package, I look forward to taking it for a spin.
-- 
Robert Melton
Hi everyone-
I've hit performance bottlenecks with JSON encoding on two projects (sky & goraft) so I wrote an alternative called megajson. I noticed that a lot of CPU time went to the "reflect" package to determine the appropriate types to serialize so megajson takes the approach of generating parsers using the "go/ast" package at compile time.
It's still in an alpha stage but I thought I'd post it to get some feedback from people around my approach.
Using the test data in encoding/json, megajson encodes and decodes about 2x faster. Obviously, YMMV.
Special thanks to Shopify for sponsoring the work on it.
Ben Johnson
[bcc: golang-dev]
If you think proto.Unmarshal(data, pb) clears the old content of pb,
you can stop reading now.
The current behavior of proto.Unmarshal(data, pb) is actually to write
the information from data into pb but leave untouched any old
information that is not explicitly overwritten or that lives in
repeated fields. This is consistent with protobuf semantics in
general, but many people don't know about this. For example, if you
have
var pb myproto.MyMessage
for 
and pb contains a repeated field, then every Unmarshal keeps appending
new values to that repeated field instead of replacing it entirely. Or
if pb has an optional field present in the first iteration but missing
in the second iteration, the second use(&pb) will still see the field
from the first iteration. The safe way to reuse pb would be
var pb myproto.MyMessage
for 
Since most people are unaware of this property of Unmarshal, most code
reusing messages does not call Reset, leading to memory leaks and
incorrect behavior. To address this, I am changing Unmarshal to call
Reset before doing the actual unmarshalling.
If you knew that Unmarshal behaved this way and wrote code depending
on the 'append' semantics, please change that code to use
proto.UnmarshalAppend.
Thanks,
Dave.
The problem with this approach is that if the C code retain this pointer,
Go's GC won't
see it, and might garbage collect it.
Of course, if you're sure C code won't keep the pointer, this approach
works fine.
I may be missing the point, so I apologize if I'm being dense. But I think
the cleanest way to do this is:
(My example code was getting a little long). It's possible to use malloc
and cast to a go pointer, and unsafe.Sizeof can help determine the size of
a structure. But by far the easiest way to do this imo is
by letting go allocate all the structures, c or otherwise.
I respectfully suggest you're over-thinking it. Take advantage of go's
awesomeness and just treat it like a normal struct.
a := &C.struct_student
sizeof is an operator, not a function. I don't think you can use
directly like that in go. You can use
C.size_t(unsafe.Sizeof(C.struct_student))
<robert.s...@gmail.com> wrote:
-- 
matt kane's brain
Try it and see. I don't think GC will collect this memory.
<robert.s...@gmail.com> wrote:
-- 
matt kane's brain
<robert.s...@gmail.com>wrote:
Not that I know of.  Usually it wouldn't make sense, since the point of cgo
is interoperability with existing code, and that would imply that you're
writing C to interoperate with existing Go...
What does gdb say?
jsing has committed a fix today. hg pull -u to get the update.
Yeah, that. Sorry I didn't say so in the first place. 
kr 
Connect the dots for me.
What does making it public accomplish?  Can't you just return that error
message/code on your own?
Just guessing -- it's to "catch" that error, not return it:
if err == http.RequestBodyTooLarge  else 
I'm using http.MaxBytesReader and I'd like to return
either status 413 or status 500 to the client, depending
on whether the limit was reached or some other error
happened.
How about making errors.New("http: request body too large")
into a public variable of package http?
kr
Hi all,
I build gdb 7.3 with python support for Windows 32bit and 64bit,
for python2.6 amd64,
for python 2.7 x86. and works runtime-gdb.py
gdb for windows crash on auto load scripts, and source command also
crash, I don't have time to digg into it, so need disable auto load
scripts for make runtime-gdb.py work. put runtime-gdb.py and create a
.gdbinit file in want debug program's folder, content as:
set auto-load-scripts off
python execfile("runtime-gdb.py")
enjoy.
--
Wei guangjing
Oops.. the wonders of copy & paste. Fixed, thanks.
-- 
Gustavo Niemeyer
-- I'm not absolutely sure of anything.
Hey all,
In case you're using the Bazaar VCS, you've likely stumbled onto
problems while trying to make the usual workflow work with $GOPATH and
the new go tool.
-- 
Gustavo Niemeyer
-- I'm not absolutely sure of anything.
OpenMail.co is hiring Go engineers in Venice, CA, just half a block from
the beach. You must be based in the Los Angeles area or be willing to move
here (we'll fly you out for an interview and pay relocation expenses).
0) We're solving fundamentally interesting problems related to discovery
and communication.
1) The technical team is still very small (2 distributed eng, myself in LA,
and all future hiring in LA).
2) Our financials are extraordinary for a company of our age/size ($20M+
revenue, very strong margins).
3) You will write Go every day.
-John Fries
jfr...@openmail.co
Hi guys,
We're on the hunt for some Go engineers in the San Francisco bay area (yes,
must be local for this unfortunately), please let me know if you're
interested.
Backend Engineer (Go)
San Francisco, CA
Join one of the leading Go companies in the world and help build next
generation, high-scale, high-performance cloud services. We're looking for
new Go developers to join the San Francisco team and work directly under
the CTO and Co-founder.
You will:
Write Go
Write more Go
Write a blog post about writing Go
Write Go
Help us organize GoSF – The worlds largest Go meetup
PS: Sorry for the spam. Unless of course you are looking for a job and this
is not spam to you, then you're welcome. ;)
Travis
Thank you Ross, I'll try it...And if you have some code to show, I'd like to see it :)
These functions usually return multiple values, the last one is the error (not nil if error happened). Check it!
Assuming a normal MIME multipart response, this should be a matter of
parsing the Content-Type header to find the boundary and passing it to
NewReader in the mime/multipart package.
(I have used Go to do exactly this to pipe the images into OpenCV.)
Ross Light | Software Engineer | li...@google.com
Hi, 
I managed to get the stream byte by byte ad it comes but I still have some missing pieces. I don't get how to use reader.NextPart(), or I don't now how to correctly  build multipart.NewReader. I always get errors like "multiple-value in single value context"
Any clues?
Thanks
Teo
The compilation error is because Connect wants a pointer. Do this instead… 
sa := &unix.SockaddrInet4
Michael Jones
michae...@gmail.com
Oh, I can successfully compiled my code both on Darwin and Linux.  Thank
you!
--
KINOSHITA Minoru
kinoshita...@gmail.com
2016年6月28日(火) 1:17 Michael Jones <michae...@gmail.com>:
There is no escape rune in the csv package, internal or otherwise.  There
is only quoting, doubling the quote to get a quote in a value.  The only
special characters are:
The separator (defaults to ')
The quote (")
The lead comment character (defaults to none)
The newline character (\n)
The carriage return character (\r)
Whitespace (unicode.IsSpace)
My point with the ability to use ' and " at the same time was, where do you
draw the line, and why is that the line?  Quoting is most complicated part
of the csv reader.  As I said earlier, making the quote character
configurable is very easy (it changes 8 lines and adds 1 line + comment +
tests) and does not break backward compatibility.  The issue is where the
line is drawn for the standard library.  I do not draw that line.
Perhaps you should use the proposal process and propose the change, perhaps
along with the change itself since it is so easy.
    -Paul
There are too many different variants of CSV out there.  We can't
support them all without producing a horrible Frankenstein's monster
of a package.  You should just copy encoding/csv into your own source
code and adjust it for your needs.
Ian
It appears declaring what constitutes a quote isn't possible. I'm working
with data published by USDA which uses a tilde to quote fields and those
fields may contain actual quotes (', "). Enforcing a set number of fields
per record and setting LazyQuotes = true does appear to work at the surface
level (I haven't inspected the actual data), but is this really enough to
guarantee data is intact as intended?
Is declaring what constitutes a quote, same as csv.Reader.Comma is used,
desirable in csv package? In my case, it would be more clear.
Well it's another concern. One could continue with "... and what about NULL
values" but these are all independent concerns. I don't think that's a
slippery slope as the features are not necessarily interdependent but the
particular change in question does expose a wider variety formats supported
without creating a Frankenstein and fitting within the current framework.
If the concern is that more requests will pour in to support arbitrary
functionality that doesn't already fit well within the current work, and no
one is prepared to respond appropriately to those requests, then it sounds
as though csv probably shouldn't have made it into the std lib. Either way,
I give more credit to you, the author, in saying the change likely wont be
accepted, and that's ok.
After reading the RFC, it appears package csv already does more than what's
suggested within so there's not much of a case to be made here if that RFC
is the guiding principal.
As far as what the USDA data does, the behavior is such a circumstance
doesn't exist. Taken from the docs:
"ASCII files are delimited. All fields are separated by carets (^) and text
fields are surrounded by tildes (~). A double caret (^^) or two carets and
two tildes (~~) appear when a field is null or blank."
Somewhat related, I happened upon the tilde usage in this:
I suppose at this point I'll probably just opt for some sort of line
scanner.
I think it's clear by the silence that a value containing ~ is considered
invalid. These types of cases aren't complications as such a view on ~ is
only narrower to what might be done with a csv parser. In the future if
they decided ~this is~valid~^ as a single field then they should stop
naming their data dumps with csv extensions.
You could then write 'The "word" is' and "Don't do that"
No. A field is quoted by a given rune, so the categorization of a set of
runes (such as quote characters ' and " in writing) is irrelevant. I'm not
personally aware if this is even possible in csv parsers out there and I've
never seen data like this. Is that something to do with Excel again?
If anything, I think the next question would be why doesn't the csv package
allow setting the escape rune, another common setting.
It's just the de facto standard, for example:
perhaps along with the change itself since it is so easy.
I'll consider it, thanks.
The RFC was the guiding principle.  I can assure you of that.  Yes, the csv
package can handle more than that, in particular, the ability to have
variable number of fields per record, the ability to have comments, the
handling of white space.  All of these were relatively common situations.
 (The white space handling is because Excel removes all leading white
space.)
The USDA spec is silent about what to do if the data has a ~ in it, so it
is not clear what to do with a ~ that is not at the start or end of the
field.  I will note the USDA spec also uses a '^' as the delimiter.
The csv package can handle what you linked to,
to use a ~ instead of a , to separate fields in a record.
I agree that it would be quite easy to make the quote character settable,
but that would beg the question of why the csv package can't handle
different quoting mechanisms.   Should it be able to handle two different
quote characters, like ' and "?  You could then write 'The "word" is' and
"Don't do that", but I don't see modifying the csv package for that at this
point, at least, not doing that and getting it into the standard library.
    -Paul
I completely understand this point of view, there is no csv "spec".
But, down the rabbit hole, is it so much to suggest configurable quotes?
For example, this data was originally being imported directly into postgres
as-is by defining a delimiter and a quote character. While it's unfortunate
that the current API uses "Comma" to define field delimiter, there's still
nothing that appears prohibitive in also defining what a quote character is.
In this case, I only see benefit. The ad-hoc defining factor here is a
delimited field can be defined by a given rune that may contain the field
delimiter. Without too much thought given to the circumstance or an
in-depth review of the code, I'm fairly certain this doesn't introduce any
strange complex behavior. If it were too, that seems like something that
should be fixed regardless.
Thanks for your input Ian.
As the person who wrote package csv (and convinced Russ to include it), I
researched many CSV formats.   I don't believe I ever found any "standard"
that used anything other than a double quote for quoting.  Unlike the other
options, quoting is not as simple as the quote character.  The problem
comes when you have a quote character inside the value.  There are multiple
ways people do this, including (with spaces to make it easy to read): " ",
" " ", \ ", " ' " ' ".  The RFC says you escape by doubling the quote (the
first in that list).  Note that this means Go's quoting (%q) is not valid
for the CSV parser.  What does the USDA do for values that contain the ~
character?
Russ was not inclined to include package csv, mainly due to lack of
standard.  Russ agreed to let it in only when I was able to point to RFC
4180.
    -Paul
Reading that it means we you also add an Escape character and default it to
the Quote character.  This is the slippery slope, the question is where the
safety net is to stop you from sliding.  Ian has indicated we have already
hit the safety net.
    -Paul
<philipp....@gmail.com> wrote:
I don't know if there is a doc.
Compared to 1.0 the tip GC runs in parallel, so it is faster.  It has
much more accurate type information, so it much less prone to, e.g.,
treating a float value as a pointer.  It is possible that by the 1.1
release it will become fully precise; currently it is (I believe)
precise for heap values but not for stack values.
However, the 1.1 GC will remain a mark and sweep collector.  It will
not be incremental, nor generational, nor will it move values around.
It is clear that it will continue to be a good idea to use pools and
custom allocators for data structures that use a lot of memory.  Work
will continue on the GC after the 1.1 release.
Ian
i'm not sure that this would work well.
1) strings: two strings with equal contents are indistinguishable
even if they're located in two different parts of memory.
2) non-heap-allocated objects: some objects larger than 64 bits
are not allocated on the heap. does every value of type complex128
have a unique number? is this changed every time the value is copied?
and what happens when Go is changed to allow equality testing
on struct values? (i do hope this will happen some time...)
I wouldn't. I'd demand that things that want to be put into sets
satisfy a non-empty interface -- eg but without prejudice, hash
and equality methods.
Chris
-- 
Chris "allusive" Dollin
map[interface]bool
?
Russ
I do agree that int64 is a lot of space overhead ..
I don't agree with the "equal things, equal hashes" because what I am
proposing is not a hash. It is a number that distinguishes objects not values.
P
Demanding equality is reasonable, demanding hashing is not.
Hashing, i.e. numbering objects when this is not necessarily a part of their
natural mathematical meaning, is a convenience implementation thing which
the compiler should support. Here's why:
autoincrement counter,
but this is a drag for the programmer to do for every object. This
cannot be implemented
in transparently in the, say, set data structure library because the
only way this library
has for distinguishing objects is by pointers (if they were
unchanging). So the programmer
would have to use a custom method for this.
I propose that Go provides a method, called something like "ObjectId"
(or whatever)
which returns an int64 that is unique for every object in the system.
In the current
implementation, this could just be the pointer to this object. But if
later the Go
folks decide to implement a copying GC, they can change the language so that the
autoincrement counter is a part of every struct.
P
Thanks Russ. This will do.
Although, for you reference, there is a scenario which cannot be
captured by this suggestion:
Imagine you want to maintain membership in a product set of
objects (i.e. AxA). If the set is very sparse, the data structure
map[interface]map[interface]bool
will not do.
P
i wonder how much that would be complicated by the fact that
pointers can point into the middle of heap objects.
Could you not leave that until the next use of the map?
[That's what I did in a dynamic language implementation.
 But that probably relied on knowing that no other thread-
 like thing was going to get in the way and that GC couldn't
 happen while the accessor/updater was working on the
 map.]
Chris
-- 
Chris "allusive" Dollin
I don't see anywhere that the language specification explicitly
guarantees it, but at least for the current implementations it should
be safe to assume that pointers don't change.
I suppose it's possible that someone might write a copying garbage
collector at some point.
- Evan
Hi,
I'm contemplating using pointers to objects as hash codes (for
placement in
a hashtable). So, are these pointers guaranteed to stay unchanged
during the
life of an object?
Thanks,
--Petar
I have a feeling that this raises an issue with the language design.
If we agree that in every language you should be able to
implement a set membership data structure, whose entries
are interface, then the question simply stands:
How would you do it in Go, without resting on hopes that the
garbage collector won't move objects in the future, or for that matter
without
using the "unsafe" package anyway.
--Petar
I don't think that works very well -- it means there's an extra
overhead of an int64 for pretty much every struct, and a struct
with structs in it will have nested overheads.
Also equal things should have equal hashes, which the scheme
above doesn't satisfy.
Chris
-- 
Chris "allusive" Dollin
I don't see why this should be part of the language, just implement it
on types where you need it.
The current implementations do not move objects.
There's nothing in the language spec that prohibits it,
and a future implementation might move objects,
but if you're writing code today it's a reasonably safe bet
that the objects won't move.
Adding to what Ian said, updating pointers into the
middle of objects is easy.  A much more annoying
complication is having to rehash any map[*foo]bar.
Russ
roger peppe <rogp...@gmail.com> writes:
A copying garbage collector has to be able to reliably locate all
pointers.  Given that, adjusting pointers into the middle of objects is
not really any harder than adjusting pointers to the start of objects.
(I don't know of any current plans to actually implement a copying
garbage collector.)
Ian
in real code, i almost never panic in response to an
error return - i'll almost always handle it in some way.
so for real code, i don't this feature would carry its weight.
when writing quick little go programs, i'll usually have
a helper function, for instance:
   f, err := foo.Bar(x)
   check(err, "bar %q", x)
this way the error message comes with appropriate context
(it tells me what the value of x was when i called Bar)
and saves me seeing a large stack trace which is rarely
what i want in these situations - i just want the program to stop
when something goes wrong.
so i wouldn't want to use this feature even for throwaway programs.
If you are tired of reading feature proposals stop reading now. Else,
use fixed-width font for best reading experience.
Panicky Assigned Values
=======================
A “panicky assigned value” is a value assigned using either = or :=,
which causes the program to panic whenever the value is not nil. It
would generally be applied to errors returned by funcs. Unfortunately,
I could not find a way to cleanly implement this feature using current
Go syntax, thus the proposal.
Just like _ (blank identifier) allows you to indicate unused assigned
value, @ (panicky identifier) will allow you to indicate a panicky
value. More precisely, this line:
a, @ := somefunc()
Is equivalent to:
a, err := somefunc()
if err != nil 
The proposed syntax is concise, clean, explicit and useful in many
situations.
Motivation
==========
In this text “error” means an intermittent environmental error, such
as lost network connection, out of memory, or out of disk space. It
does not mean programmer error or a bug.
By convention errors are returned as the last return value of a
function. There are two things that a developer can do with an error,
ignore it or handle it.
This is how you ignore the error:
a, _ := somefunc()
This is how you handle the error:
a, err := somefunc()
if err != nil 
In practice, you rarely want to ignore an error. Most often you want
your program to handle the error. The three popular choices are: halt
the program (or at least the routine/request handler), pass the error
up the stack to the caller, and finally recover from the error (e.g.
renew the network connection and try again). In more complex cases it
can be some combination of the three.
In a complex fast-paced release-early-release-often software
development environment, e.g. web apps, it is common to start with the
halt-the-program reaction to intermittent errors, and as the project
matures you gradually add proper error handling to make it more
robust. By then you gain knowledge about your system, including which
errors should be handled and how. In the beginning though, halting on
error is a safe lazy choice. A non-robust program can still be useful
and can be good enough in the early stages, when the team is small and
the features and algorithm correctness are more important than
robustness/performance/etc. You don’t want to get stuck in premature
optimization, or I should say premature productization.
More importantly, in many cases halting the program on certain errors
_is_ the desired behavior. In these cases an “if” statement for each
error is just noise.
Unfortunately, the most concise, the laziest, the most release-early-
release-often-friendly syntax is available only for ignoring errors,
which is never a safe choice even for early-stage projects. This
motivated me to come up with a similarly easy syntax for halting
programs when errors are detected. Without it developers are
incentivized to ignore errors, waste their time on premature
productization and/or pollute their code with boilerplate.
Looking through the mailing list you can see that dropping errors (_)
instead of handling them seems to be one of the most common mistakes
people make. To my mind, providing some implicit panic is not less
harmful. It would most probably be used as the standard handling for
errors... people stop actually thinking about possible errors because
they are not gonna handle them anyway. This will result in programs
that panic every tiny error, even if it could be handled in a clean
way.
I am sure that your idea might be useful for people who know how to
deal with it (as you described... early stages only and so on). But
people do not know or do not want to know because they are to lazy at
the moment, they want to add correct error handling later, later is
never going to happen, and so we end up with a bunch of constantly
panicing programs.
For the early stages of development some simple script that does some
search&replace could do what you are suggesting without affecting the
language itself.
2011/12/8 Peter Bourgon <peterb...@gmail.com>:
As has been pointed out, there are ways of concisely declaring that a
non-nil error will panic.  Whether you go the more verbose route proposed
above or a simple chk(os.Error) function is up to you.  As you say, Go is a
tool, and you can use it however you wish.
And for developing features quickly and iterating rapidly?  I find error
checking *absolutely essential* for these tasks.  While I may not return an
error when I find it, I will always at least print it out or fire it off at
our monitoring solution.  This short circuits a lot of debugging when I see
when something might cause an error later and the fact that it doesn't
panic allows it to continue on with whatever else it was doing without
completely falling over and requiring a code change to proceed.
Yegor wrote:
Panic eventually gets replaced by actual error handling. The same
conditional branches on error in both cases.  When you replace panic
with proper error handling the branching code will be written
eventually, so why not do it in the first place? Why use a mechanism
only to replace it with something else afterwards?
Checking for errors is explicit and feels natural, even to programmers
not familiar with Go, your proposal proposes something that is
explicit in the sense that the programmer must express intent, but is
cryptic and incomprehensible for a programmer not familiar with the
language or with the feature. While the code is shorter, I feel it
weights more on the page.
In those cases, I think the conditional is not noise, but the best
thing you can do. If you want to panic, panic, it's your decision, not
compiler's. Don't hide it inside some cryptic statement, make it clear
and visible to the reader.
-- 
Aram Hăvărneanu
Just to clarify, according to the proposal:
I find it quite explicit. You know before you run your program how it
will behave. The problem with implicits is compile-time ambiguity,
e.g. in some languages when you mistakenly add a float to an int the
compiler automatically performs type conversions instead of failing
compilation.
I would much rather train people to handle errors properly than to simply
panic for everything.  That sounds like exceptions to me.  If that takes
them getting bitten a few times when they ignore error returns, then I
think it's an overall win.
~K
Yegor wrote:
Of course, but you mentioned that people panic in prototype code and
replace the code with proper error handling later.  I was responding
in that context.
Typing that extra two lines of code does not take much time.  In my
experience I spend significant less time typing code compared to other
programming tasks like thinking things through, reading code,
analyzing how code works, debugging, etc.
Even if you don't know what _ is you can still read code that uses it
and understand it.  On the other hand @ has side effects that the
reader need to be aware of.
In my experience, if people want to ignore errors, no language feature
will stop them.  Too many people add catch all clauses in Java to stop
the program crashing, even though the catch all does not do anything.
The syntax to ignore errors exists today.  If some people chose to
abuse it, your feature won't stop them.
In my opinion, the least context a reader needs to understand
something, the better.  The code should tell the reader exactly what
it does.  I am not a fan of syntactic shortcuts and magic language
features.
Every syntactic idiom in a language burdens a great weight on the
shoulders of the reader.  It is always a trade off between
expressiveness, utility and clarity.  I feel Go makes this trade off
better than every other language I have worked with.  I feel that
adding alternative syntax without adding expressiveness would tip the
balance Go strives for.
Because Go code is straightforward, explicit, and lacks syntactic
sugar reading and answering these questions is easy.
Then don't panic and make your code clearer.  I believe error handling
is part of the algorithm, and that you can have very clear code even
if you do proper error handling.  I think you can write error handling
without sacrificing the readability of your code.
Go is more concise than most languages used in the industry today.  I
disagree that _ promotes error ignorance, but even if that's the case,
@ doesn't change that.  People can still abuse _ if they are so
inclined.
Conciseness is not a virtue, clarity is.  They are related, but it's
not a linear relationship.  I think Go succeeds to maximize clarity.
-- 
Aram Hăvărneanu
Or just write Go in the standard style and see if it grows on you. If
after writing a few thousand lines of code you still find it
unbearable, come back to this.
Dave.
You've mentioned two problems you have with the language:
1. It's tedious to write error-handling code.
2. It's too easy to ignore errors.
I happen to agree. I think both of those things are flaws with the
language.
My fantastized solution to #1 is a must() built-in. If f is a function
whose last return type is error, then must(f(...)) panics if that
error is non-nil, else it returns the other return values, omitting
the error. E.g. instead of
n, err := w.Write(bytes)
if err != nil 
one could write
n := must(w.Write(bytes))
I don't think we'll ever have that built-in, but someday someone will
write a smart enough macro system for Go (it would have to understand
types), and then you could write must() yourself.
Anyway, thinking about must() at least lets us separate the semantics
of your proposal from the syntax, since must() has the syntax (and the
semantics!) of an ordinary call. You can't write it in Go solely for
type reasons.
I should add that I personally would only use must() for initial
prototyping, pedagogical code (I hate "this code omits error checking
for clarity") or in those rare cases where panicking is really the
right thing to do. I believe that most of the time it isn't.
For #2, namely the problem that's it too easy to write
f(x)
when f returns an error, I again have a language-y solution and a tool-
y fallback. I wish there was a way to annotate a function return value
so that it would be a compiler error for the caller to ignore it. Gnu C
++ has something like this as an extension, and I happen to like it.
Callers could still ignore errors if they wished, by writing
_ = f(x)
but they'd have to go out of their way. Note that the proposal is not
"a return value of type error must never be ignored," because some non-
error return values might be important to check, and some error return
values might not be.
Since that's never going to get in the language (the discussion has
been had), the fallback is to have a tool, like govet, find these
situations and warn about them.
TL;DR with suitable tooling (NYI), Go can have the error-handling
behavior that you want.
I've just realized that my solution sucks big time. I kept assuming
that the returned values are always assigned. What if they are not? A
demo:
a, _ := foo()
a, @ := foo()
I'll have to start over.
Yegor
Not true. There are tons of wonderful Java and C++ programs out there
that may not be 100% robust (if that's possible at all) but they don't
"constantly panic". You see, you can create great programs even in
languages that suck.
Ignoring errors is a bad idea, even at the early stages of your
project. A compiler warning is not enough.
$ cat `find | grep .go$` | wc -l
1806
and in another folder
495
So 2301 lines so far. A lot of it is just tinkering: solutions to
projecteuler.net problems, simple algorithms and one small app-engine
app. So far I love everything about Go, except error handling. I don't
think it's safe. I know, there are tutorials, blogs and discussions
filled with information about Go error handling. But the huge amount
of information on this topic only indicates that there is a problem.
I am an app developer. A lot of advice seems to come from systems
people, and Go did start as a systems programming language. The app
programming world is a little different, which might explain why this
advice isn't very convincing to me. With apps you deal with business
people, deadlines and ambiguity. The development process is structured
differently. You have to sacrifice robustness and performance before
you even know what your app is supposed to do, all while your app is
in production. So I need a safe error handling mechanism.
I am still optimistic that there is a solution that suits both use-
cases: the rigorous systems programmers and the lazy distracted app
developers like myself. After all Go on App Engine is going to be used
for apps, not systems.
Yegor
Who are you quoting? I reread my proposal, and I could not find the
word "implicit" in it. I am proposing the exact opposite, an
_explicit_ panicky identifier.
that's the kind of thing that could be added to govet if desired.
although it would be annoying to see all those ignored errors
from fmt.Printf, x.Close(), etc.
From past conversations I believe the consensus is that panic is
appropriate for programming/technical errors while error is for everything
else.
christoff...@forsvikgroup.com> wrote:
wrote:
A common enough experience with Java and C++ programs ;)
What the OP actually wants is a kind of assert statement/builtin
function.
What _could_ be useful is a compiler warning that tells you where you
have been ignoring errors. That can be easily converted into a compile
error for the paranoid. (Although knowing if an ignored second value
is actually an error is not so simple.)
steve d.
This is because you choose to follow a different software development
process, which by far isn't the only one.
Quick little Go programs or throwaway programs are not what this
proposal is targeting. On the contrary, it is targeting large complex
projects where nothing is final for a while, so you don't want to
waste your time on things like proper error handling in a component
that may not even make it into the final product, but at the same time
you don't want to blindly ignore errors. When you are writing a web-
app, your first priority is to make it useful, not 99.99% SLA. It can
actually gain a decent user base even with occasional glitches, as
long as you are not corrupting user data. First come features, then
come robustness and performance.
I'm not quoting anyone, rather coining a phrase. For me, explicit
panic means you explicitly call the panic builtin.
  if val, err := foo(bar); err != nil 
Whereas "implicit" panic means a panic may be triggered as a side
effect of some (any) other action,
I prefer the first to the second. But I think you make a reasonable-enough case.
I'm not seeing the problem. Maybe it's a lack of sophistication of my code.
In my simple interpreter, I have lots of little leaf functions that
operate on a stack. The exported function is Eval. The internal
functions do stuff like this:
 x := toInt(stack)
 y := toInt(stack)
Bad things happen, of course, if the stack is empty or the top of
stack value can't be turned into a number.
Now, in an earlier form, that code was awful:
 tos, err := stack.pop()
if err 
i, err := strconv.Atoi(tos)
if err 
Yuck! But then another couple go talks (Andrew's and Rob's) once again
changed my life.
So I put a recover in Eval, following the example from Andrew's nice
talk, and only two functions (pop and toInt) do panic, and I end up
with code like this:
Now, this may still not be perfect, but the rules I took away were simple:
- one or two internal functions that panic
- other functions that don't panic, and don't do all the if err != nil
tests, but *use* those internal functions which will panic if needed
- the exported function recovers and returns an Error
and it has worked well for me.
But, again, maybe my experience to date does not encompass complex
enough situations.
Error handling is always the worst part of anything I've ever written.
I think it's good that Go forces people to code for it and really
think about it. Just my $.02.
ron
<christoff...@forsvikgroup.com> wrote:
Not perhaps as concise as you'd wish, but grepping for "panic"
in $GOROOT/src/pkg/*/*.go will give you a good range of examples.
As for idiomatic use of recover, the go/printer and encoding/json packages
both use panic and recover to simplify their error handling.
(the panic and recover code there should be relatively straightforward
to understand without needing to grok the entire package source)
Not exactly, in many cases you just want to panic.
Because of project priorities. You want features first, 99.99% SLA
second. And in those cases where you simply want to panic, you won't
replace it at all.
That's the nature of learning a new language. Go already has plenty of
features that feel pretty alien to newcomers. Plus, there's not much
difference between these two lines in terms of readability:
a, _ := foo(bar)
a, @ := foo(bar)
It's just that the second line is a safer choice when the second
return value happens to be an error. You don't want to incentivize
newcomers from other languages to ignore errors by giving them a
convenient syntax to do so.
The primary objective and the most frequently traveled path of any
This is why for any reader of the function's code the first question
is "How does the function produce the correct result in the absence of
errors?" The second question is "How does the function behave when an
error occurs?", and is only important after the reader got their
answer to the first question. If your algorithm is hidden between
multiple blocks of error handling code that just panics, you make it
harder for the reader to understand your code. Explicit and concise is
what makes your code "clear and visible". The current approach is
"explicit and verbose" and promotes error ignorance. If Go's target is
to "feel like a dynamically typed language", conciseness is one trait
it must strive for. If it's goal is to discourage error ignorance it
should provide syntax that competes with ignoring errors.
Several problems with this approach:
- Such a function would have to be built-in or in the standard lib,
otherwise you end-up everyone implementing their own version
- The syntax is still fairly dirty:
a, err := Func1()
MaybePanic(err)
b, err := Func2()
MaybePanic(err)
c, err := Func3()
MaybePanic(err)
- The stack trace points to the wrong line in the code
- Not official, so people are not aware of this option
The Must* convention is for use in initializing global variables, usually.
 It's often best to use the non-Must* variants in code.
I usually design my programs so that errors travel through the stack
to that point of origin where I handle them. It is quite rarely that I
actually use the panic/recover mechanism.
For the sake of this discussion, can anyone give a good and concise
use case of panic? (and maybe recover too)
That is a major motivator for this proposal.
You are the second person to label it as "implicit". Please explain
what is implicit about it.
I disagree. People do go back and fix programs that crash after
identifying the reason for the crash and coming up with the solution.
I have not seen many programs that "constantly panic". A lot of
programs, even those hacked up in a weekend, run ok.
Yes, but ignoring errors even at the early stage is not an option, as
you may be corrupting data and making your program extremely hard to
debug because the program crashes way after the ignored error maybe
even in another part of the system.
Do you think it is a good idea for any program to "implicitly panic",
that is, panic without explicitly calling panic()? This seems to me to
be quite a lot of magic under the covers, and requires quite some
serious justification.
i won't comment on the  usefulness of this or whether or not it's a good idea... but  unless i misunderstood i don't think you need any special syntax for tjis. just write a function that  takes an error and does what it will. 
1. A programming language is just a tool. When you say you want to
train people that's a big red flag against wide adoption. A successful
programming language should be adaptable to different development
processes.
2. "to handle errors properly" in many cases is to panic
I do not suggest that you panic for _everything_. I suggest that it's
more often better to panic than to ignore an error.
Unfortunately corrupted data and hard to debug code doesn't always
bite the original author of the code, but also the users and other
people in your company.
Аspects of the problem:
- The convention in the Go libraries is that even when a package uses
panic internally, its external API still presents explicit error
- panic means "everything goes wrong". The sense of what is wrong
depends on a context. Cases of a library and an end-user app are
different.
- "if e != nil " and "if e != nil " occur too
often
- _ exists to omit a result value variable. The use of _ is harmful.
I.e. f, _ := os.Open("name"). f is nil, nil-pointer panic occurs. why?
- Making the error handling too special leads to the exceptions in
Java or C++. But os.Error have become error. And error tends to be the
last result value.
In my experience I also think that some short way to panic if error is
not nil would be convenient.
Let's consider API (or look at mysql or redis libraries in Go)
- db.OpenDb(name string) (*Db, error)
- db.(*Db).Get(key []byte) ([]byte, error)
- db.(*Db).Exists(key []byte) (bool, error)
- db.(*Db).Put(key, value []byte) error
error can be out-ouf-memory, out-out-diskspace, network problem
And app that handles http requests and manipulates some databases.
Aspects:
- db API should definitely return error. See the first aspect.
- I can check OpenDb's error once. But checking of Get, Exists and Put
leads to endless "if e != nil " or "if e != nil "
- "if e != nil " is really sensible in this context since
these errors means "everything goes wrong".
Possible solution:
- Make a wrapper in a package of application: MustGet(key []byte)
[]byte, MustExists(key []byte) bool, MustPut(key, value []byte)
- Some other approaches? Am I wrong? Inconveniences does not exist? Or
they are insignificant?
Hi,
I released jsondoc a command line tool used to simplify creation of
documentation of HTTP (REST) JSON APIs for projects written in Go. The
input and/or output JSON structure for particular endpoints is obtained
from named types from selected Go packages. The output of jsondoc is an
HTML file with embedded CSS.
Example output:
Repo and description:
Regards,
Łukasz Pankowski
I have a package that provides a
that may do what you want.
Cool. Can build now. Have testing error, will take a look later.
You're probably using an older version of Go, back from when it was at
"exec", instead of "os/exec".
You didn't say which version of Go, though.
It'll be a lot of work changing go-fuse.  Just roll back to an earlier
version of go-fuse (perhaps there are tags for r60), or move your Go
version up to a latest weekly.
$ 6g -V
6g version release.r60.3 9516
Let me try to change code in go-fuse.
Hi there,
Below is what I faced. Any ideas?
$ env | grep GO
GOBIN=/home/xiaofengguo/code/hg/go/bin
GOARCH=amd64
GOROOT=/home/xiaofengguo/code/hg/go
GOOS=linux
GOPATH=/home/xiaofengguo/code/hg/go
$ 6g mount.go
mount.go:7: can't find import: os/exec
Best Regards,
Xiaofeng
Everything in exp is experimental and even less committed to
than the rest of the "standard" distribution.  Iterating over data
structures using channels can be powerful but is not as cheap
as a simple for loop.  Most Go code does not use this idiom
unless there is a redeeming reason (like it makes the code a
lot easier to write).
Russ
tiny_dust <ustc....@gmail.com> writes:
References are equivalent to pointers except that they introduce an
implicit & operation and you can't have pointers to pointers.  Neither
change seems desirable to me.  Nobody is forcing you to use pointers,
but they are a useful construct in a language like Go which gives you
control over the memory layout of your data.
No, we can't, at least not without other changes.  An expression
statement may start with "struct"
	struct  
and a block statement may start with "

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

----hi i am here----

[['there', 'effort', 'go', 'nacl', 'support', 'point', 'similar'], ['be', 'suggest', ' ', 'have', 'take', 'look', 'dart', ' ', 'to'], ['suitable', 'replacement', 'javascript', 'go'], ['-PRON-', 'think', 'use', 'go', 'directly', 'browser'], ['independently', 'have', 'compiler', 'go', 'javascript'], ['at', 'idea', 'build', 'vm', 'go', 'but', 'not'], ['necessary', 'tool', 'run', 'go', 'code', 'like', 'script'], ['-PRON-', 'think', 'run', 'go', 'code', 'brwser', 'easy', 'like'], ['install', 'go', 'toolchain', 'command', 'compile'], ['library', 'mb', '--except', 'library', 'function'], ['unsafe', 'like', 'function', 'package', 'os', 'library', 'unsafe"--'], ['and', 'course', 'browser', 'allow', 'use', 'go'], ['toolchain', 'key', 'point', 'do', 'anybody', 'experience'], ['browser', 'be', 'possible'], ['advantage'], ['+', 'one', 'specification', 'code', 'not', 'break', 'different'], ['browser', 'this', 'great', 'problem', 'js', 'microsoft'], ['+', 'one', 'language', 'development', 'advantage', 'go'], ['+', 'the', 'library', 'cache', 'speed', 'web'], ['application'], ['and', 'short', 'time', '-PRON-', 'will', 'use', 'language', 'clean', 'sintaxis'], ['non', 'verbose', 'like', 'go', 'client', 'way'], ['compile', 'go', 'js'], ['java', 'client', '-PRON-', 'choose'], ['nacl', 'different', 'proposal', 'nacl', 'build', 'run', 'native'], ['code', 'web', 'code', 'compile', '-PRON-', 'think'], ['bad', 'dark', 'web', "cann't", 'know'], ['go', 'nacl', 'program', '-PRON-', 'proposal', 'compile', 'go'], ['program', 'browser'], ['nacl', 'sandox', 'avoid', 'access', 'system', 'call', 'but'], ['not', 'necessary', 'go', 'program', "cann't", 'access', 'directly'], ['system', 'call', 'easy', 'like', 'avoid', 'calling', 'c'], ['library', 'go', 'code'], ['hello', 'now', 'bitbucket', 'officially', 'provide', 'git', 'repo', 'host', 'want'], ['install', 'package', 'bitbucket', 'git', 'repo', 'need'], ['goinstall', 'able', 'fetch', 'git', 'repos', 'becouse', 'think', 'bitbucket'], ['contain', 'mercurial', 'repos'], [], ['vasiliy', 'tolstov'], ['clodo.ru'], ['e', 'mail', 'v.to...@selfip.ru'], ['jabber', 'va...@selfip.ru'], ['-PRON-', 'have', 'submit', 'cl', 'add', 'support'], [], ['julian'], ['2011/10/26', 'julian', 'phillip', '<', 'jul...@quantumfyre.co.uk', '>'], ['thank'], [], ['vasiliy', 'tolstov'], ['clodo.ru'], ['e', 'mail', 'v.to...@selfip.ru'], ['jabber', 'va...@selfip.ru'], ['-PRON-', 'think', 'will', 'use', 'explicit', 'goinstall', 'form'], ['2011/10/25', 'dmitry', 'chestnykh', '<', 'dch...@gmail.com', '>'], ['can', 'possible', 'fix', 'release'], [], ['vasiliy', 'tolstov'], ['clodo.ru'], ['e', 'mail', 'v.to...@selfip.ru'], ['jabber', 'va...@selfip.ru'], ['forgot', 'reference'], [], ['aram', 'hăvărneanu'], ['google', 'search', 'good', 'find', 'related', 'result'], [], ['embrace', 'active', 'project', 'use', 'maybe'], ['reach', 'project', 'not', 'active', 'project', 'simply', 'require'], ['custom', 'build', 'step', 'gettable'], ['webkit', 'wka', 'those', 'wrapper', 'webkit', 'engine', 'webkit', 'use'], ['gtk', 'binding', 'gtkwebkit'], ['gtk', 'binding', 'gtk', 'this', 'bind', 'good'], ['uik', 'user', 'interface', 'toolkit', 'pure', 'go', 'use', 'wde'], ['rasterization', 'event', 'capture', 'project'], ['start', 'not', 'expect', 'great', 'collection', 'widget'], ['wde', 'low', 'level', 'api', 'render', 'thing', 'capture', 'event'], ['require', 'cgo'], [], ['andré', 'moraes'], ['john', 'asmuth', "'s", 'go.wde', 'go.uik', 'ideal', 'choice', 'create'], ['graphic', 'sam'], [], ['aram', 'hăvărneanu'], ['haha', '-PRON-', 'suppose', '-PRON-', 'not', 'know', 'sam'], ['there', 'multi', 'line', 'text', 'area', 'widget'], ['yes', 'be', '-PRON-', 'explicitly', 'answer', 'be', 'good', 'implement'], ['graphic', 'sam', '-PRON-', 'good', 'be'], ['certainly', 'good', 'sam'], [], ['aram', 'hăvărneanu'], ['-PRON-', 'look', 'like', 'cmd', 'start'], ['just', 'not', 'use', 'wait'], ['-PRON-', 'tell', 'application', 'depend', 'chrome', 'instal'], ['fire', 'external', 'process', 'go', 'app', 'point', 'browser'], ['localhost'], ['not', 'sure', 'require', 'tweak', 'cef', 'example'], ['application', 'minor', 'way', 'run', 'executable'], ['communicate', 'want', 'zeromq', 'websocket', ' ', 'as', 'long'], ['build', 'installer', 'place', 'golden'], [], ['robert', 'melton'], ['afaik', 'node', 'webkit', 'version', 'window', 'maco', 'linux'], ['the', 'look', 'feel', 'window', 'native', 'not', 'tell'], ['diference', 'node', 'webkit', 'window', 'win32', 'window'], ['-PRON-', 'think', 'able', 'set', 'size', 'window'], ['problem', 'check', 'node', 'webkit', 'doc', 'sure'], ['the', 'renderer', 'use', 'chrome', 'able'], ['use', 'node', 'webkit'], [], ['andré', 'moraes'], ['2013/8/9', 'bronze', 'man', '<', 'bronz...@gmail.com', '>'], ['how', '-PRON-'], ['create', 'simple', 'html', 'page', 'node', 'webkit', 'project', 'combine'], ['chromiun', 'source', 'code', 'nodejs'], ['after', 'html', 'page', 'load', '-PRON-', 'use', 'nodejs', 'stdlibrary', 'fire'], ['application', 'create', 'websocket', 'i', 'o.'], ['everything', 'inside', 'go'], [], ['andré', 'moraes'], ['yes', 'fmt', 'fprint', 'interpret', '-verbs', 'string'], ['-character', 'string', 'beware'], ['-PRON-', 'assume', 'question', 'general', 'specific', '\n ', 'string', 'str'], ['chris'], [], ['chris', 'allusive', 'dollin'], ['no', 'fprint', 'use', 'format', 'string', 'fprintf'], ['--benny'], [], ['the', 'essential', 'chemistry', 'perform', 'practical'], ['work', 'conduct', 'experiment', 'perform', 'practical', 'work'], ['make', 'experiment', 'attain', 'degree', 'mastery', '\n\xa0 \xa0 \xa0 \xa0 ', 'abu', 'musa', 'jabir', 'ibn', 'hayyan'], ['fx', 'peer', 'closely'], ['dagnabbit', 'so', 'not'], ['thank', 'catch'], ['chris'], [], ['chris', 'allusive', 'dollin'], ['be', 'difference', 'use', '`', 'fmt', 'fprint(os', 'stdout', 'str', '`'], ['`', 'os', 'stdout', 'write([]byte("str', '`'], ['-PRON-', 'be', '`', 'os', 'stdout', 'write', '`', 'write', 'ansi', 'terminal', 'escape', 'control'], ['if', 'want', 'output', 'specific', 'byte', 'string'], ['string', 'format', 'write', 'straight', 'os', 'stdout', 'fmt'], ['thing', 'eventually', 'not', 'need'], ['functionality', 'skip'], ['andrew'], ['fprint', 'print', 'datum', 'type', 'stdout', 'write', 'print', 'byte'], ['slice'], ['-daniel'], ['hi'], ['-PRON-', 'have', 'release', 'tool', 'manage', 'machine', 'image', 'multiple', 'provider'], ['-PRON-', 'be', 'alpha', '-PRON-', 'be', 'develop', '-PRON-', 'think', 'be', 'good'], ['any', 'feedback', 'contribution', 'welcome'], ['regards'], [], ['fatih', 'arslan'], ['sorry', '-PRON-', 'need', 'cast', 'variable', '\n   ', 'memoryblock[2', '=', 'byte(256', 'int(memoryblock[2'], ['so', 'be', 'assign', 'byte', '-PRON-', 'think', 'go', 'treat'], ['constant', 'byte', ' ', 'a', 'byte', 'encode', '-PRON-', 'need'], ['extra', 'bit', 'ie', 'byte', 'store', '  ', 'something', 'like'], ['follow', 'work', 'silly', '\n ', 'memoryblock[2', '=', 'byte(int(256', 'int(memoryblock[2'], ['vase', '<', 'v.to...@selfip.ru', '>', 'write'], ['go', 'currently', 'support', 'loading', 'share', 'library'], ['ian'], ['hello', '-PRON-', 'be', 'try', 'learn', 'language', 'c', 'daemon', 'listen'], ['sock', 'json', 'request'], ['all', 'request', 'serve', 'c', 'share', 'library', 'dinamyc', 'load'], ['runtime', 'list', 'config', 'file', 'after', 'daemon', 'recief', 'reuest'], ['pass', 'module', 'wait', 'response', 'serve'], ['client'], ['-PRON-', 'be', 'able', 'find', 'thread', 'ability', 'run', 'module'], ['language'], ['how', 'extent', 'base', 'daemon', 'function', 'module', 'case', 'use'], ['go', 'be', 'possible'], ['if', 'need', 'case'], ['finally', 'want', 'daemon', 'able', 'use', 'module', 'if', 'need'], ['new', 'function', 'daemon', 'module', 'discribe', 'command'], ['serve'], ['p.s.', 'if', 'want', 'write', 'support', 'specific', 'protocol', 'case'], ['xenstore', 'xen', 'domu', 'what', 'need'], ['thank', '-PRON-', 'suggestion'], ['go', 'not', 'support', 'dynamic', 'loading', 'go', 'code', 'process', 'space'], ['here', 'different', 'idea', 'achieve', 'want'], ['use', 'standard', 'rpc', 'gob', 'module', 'talk', 'external', 'go'], ['process', 'define', 'api'], ['define', 'simple', 'protocol', 'implement', 'unix', 'socket'], ['stdin', 'process', ' ', 'this', 'advantage', 'plugin'], ['language'], ['embed', 'dynamic', 'language', 'project', ' ', 'lua', 'good', 'candidate'], ['instance'], ['there', 'way', 'serve', 'inspire'], [], ['gustavo', 'niemeyer'], ['-PRON-', 'file', 'patent'], ['can', 'not', 'cgo', 'load', 'library', 'c'], ['usual', 'solution', 'close', 'channel', 'wait'], ['thing', 'end', 'signal', 'be', 'finish'], ['sync', 'waitgroup', 'nice', 'solution'], ['gustavo', 'niemeyer', "'s", 'tomb', 'package'], ['provide', 'useful', 'structure', 'kind', 'situation', 'particularly'], ['want', 'retrieve', 'error'], ['-PRON-', 'have', 'come', 'situation', 'time', 'write', 'application'], ['-PRON-', 'wonder', 'good', 'way', 'handle'], ['say', 'package', 'send', 'email', 'buffered', 'channel'], ['goroutine', 'process', 'channel', 'send', 'email'], ['then', 'application', 'send', 'email', 'datum', 'channel'], ['get', 'send', 'asynchronously'], ['if', 'application', 'exit', 'goroutine', 'chance', 'process'], ['element', 'channel', 'email', 'get', 'send'], ['so', 'good', 'way', 'handle'], ['-PRON-', 'guess', 'shutdown', 'function', 'email', 'package'], ['exit', 'application', 'trap', 'quit', 'interrupt', 'signal'], ['call', 'exit', 'main', ' ', 'in', 'shutdown', 'function', 'close'], ['channel', 'wait', 'channel'], ['but', '-PRON-', 'imagine', 'elegant', 'solution', '-PRON-', 'not', 'know', ' ', 'any'], ['tip', 'appreciate'], ['thank'], ['tom'], ['-PRON-', 'know', 'problem', ' ', 'unfortunately', 'google', 'groups'], ['large', 'target', ' ', '-PRON-', 'be', 'hard', 'job', 'perfectly', ' ', '-PRON-', 'sure'], ['far', 'spam', 'reject', 'get'], ['russ'], ['spam', 'mailing', 'list', 'annoyance', 'subscriber', 'please'], ['look', 'issue'], ['s.'], ['-PRON-', 'correct', 'gomake', 'us', 'need', 'mingw', '-PRON-', 'run', 'compile', 'link', 'command', 'g', '8l', 'hand', 'batch', 'file', 'verbose', 'complicated'], ['-PRON-', 'hope', 'change', 'soon', '-PRON-', 'believe', 'goinstall', 'get', 'rewrite', 'moment', 'replacement', 'gomake'], ['alex'], ['how', 'build', 'package', 'hand', 'gomake', 'not', 'work', 'window'], ['hi', 'all'], ['-PRON-', 'develop', 'json', 'rest', 'api', 'server'], ['currently', 'use', 'struct', 'save', 'resource', 'receive'], ['rest', 'request', 'and', 'consider', 'use', 'separate', 'struct', 'receive'], ['request'], ['let', 'simplified', 'example'], ['-PRON-', 'would', 'createdat', 'updatedat', 'generate', 'system'], ['external', 'input'], ['so', 'need', 'check', 'client', 'define', 'value', 'e.g.', 'post'], ['strip'], ['that', 'be', 'create', 'struct', 'handle', 'request'], ['by', 'struct', 'handle', 'request', 'not', 'need', 'strip', '-PRON-', 'would'], ['createdat', 'updatedat', 'post', 'put', 'request'], ['but', 'struct', 'create', 'maintainability', 'issue'], ['need', 'sure', 'resrequest', 'update', 'need'], ['update', 'res'], ['by', 'struct', 'receive', 'request', 'save', 'db'], ['simple', '-PRON-', 'use', 'gorm'], ['-PRON-', 'like', '\n  ', 'var', 'r', 'res', '\n  ', 'json', 'unmarshal(b', 'r', '\n  ', 'db', 'save(r', '\n  ', 'writeheader(201', '\n  ', 'writejson(&r'], ['which', 'method', 'think', 'idiomatic', 'good', 'go', 'point', 'view'], ['thank'], [], ['-brad'], ['also', 'change', 'import', 'deps', 'recursive', 'dependency'], ['deps=$(go', 'list', '-f', '$'], [], ['fatih', 'arslan'], ['from', 'test', '-help', '\n    ', '-coverpkg', 'pkg1,pkg2,pkg3', '\n        ', 'apply', 'coverage', 'analysis', 'test', 'give', 'list'], ['package', 'the', 'default', 'test', 'analyze', 'package'], ['test', 'package', 'specify', 'import', 'path'], ['e.g.', 'directory', 'package', 'a', 'run', 'test', '-coverpkg', 'a', 'b', 'c', '\n    ', '-chris', 'k'], ['be', 'way', 'automatically', 'include', 'dependent', 'package', '-PRON-', 'not'], ['mention', 'help'], ['deps=$(go', 'list', '-f', '$'], ['test', '-coverpkg=$deps'], ['this', 'include', 'import', 'the', 'output', 'like'], ['pass'], ['coverage', 'statement', 'error', 'fmt', 'reflect', 'string'], ['ok', ' \t', 'github.com/fatih/struct', '\t', '0.008s'], [], ['fatih', 'arslan'], ['if', 'be', 'try', 'coverage', 'subpackage', 'ci'], ['not', 'concerned', 'downstream', 'package', 'manually', 'toggling'], ['one', 'runtime', '-PRON-', 'have', 'script'], ['travis', 'work', 'fine'], [], ['dave'], ['thank', 'helpful', '-PRON-', 'try', 'modify', 'output', 'set'], ['package', 'start', 'prefix', 'hopefully', 'will', 'soon'], ['thank'], ['done', 'add', 'encoding', 'json', 'benchmark', 'input', 'autobench', 'pick', 'automatically'], ['thank', 'ugorji', 'this', 'library', 'awesome'], [], ['disclaimer'], ['this', 'investment', 'recommendation', 'solicitation'], ['investor', 'firm', 'unless', 'indicate', 'view', 'author', "'s"], ['differ', 'firm', 'firm', '-PRON-'], ['represent', 'accurate', 'complete', 'update', 'past'], ['performance', 'indicative', 'future', 'return', 'for', 'additional', 'information'], ['important', 'disclosure', 'contact', 'email', 'address', '-PRON-'], ['use', 'email', 'request', 'authorize', 'investment', 'security'], ['instrument', 'effect', 'transaction', '-PRON-', 'guarantee'], ['request', 'receive', 'email', 'process', 'timely', 'manner'], ['this', 'communication', 'solely', 'addressee(s', 'contain'], ['confidential', 'information', '-PRON-', 'waive', 'confidentiality'], ['mistransmission', 'contact', 'wish', 'receive'], ['communication'], ['robert-'], ['let', 'know', 'work', 'test', 'coverage', '-PRON-', 'be', 'go', 'bump', 'soon', '-PRON-', 'be', 'loc', 'not', 'hard', 'grok', 'let', 'know', 'question'], ['bug', 'report', 'pull', 'request', 'welcome'], ['ben'], ['alberto', 'sorry', 'necro', 'thread', 'plan', 'release'], ['optimize', 'json', 'library'], ['write'], [], ['disclaimer'], ['this', 'investment', 'recommendation', 'solicitation'], ['investor', 'firm', 'unless', 'indicate', 'view', 'author', "'s"], ['differ', 'firm', 'firm', '-PRON-'], ['represent', 'accurate', 'complete', 'update', 'past'], ['performance', 'indicative', 'future', 'return', 'for', 'additional', 'information'], ['important', 'disclosure', 'contact', 'email', 'address', '-PRON-'], ['use', 'email', 'request', 'authorize', 'investment', 'security'], ['instrument', 'effect', 'transaction', '-PRON-', 'guarantee'], ['request', 'receive', 'email', 'process', 'timely', 'manner'], ['this', 'communication', 'solely', 'addressee(s', 'contain'], ['confidential', 'information', '-PRON-', 'waive', 'confidentiality'], ['mistransmission', 'contact', 'wish', 'receive'], ['communication'], ['hi', 'ben'], ['with', 'permission', '-PRON-', 'would', 'like', 'add', 'megajson', 'autobench', 'harness'], ['here', 'raw', 'datum', 'compare', 'megajson', 'run', 'vs', '1.2rc3'], ['megajson'], ['benchmark', '              ', 'old', 'ns', 'op', '   ', 'new', 'ns', 'op', '   ', 'delta'], ['benchmarkcodeencoder', '    ', '    ', ' ', '-27.69'], ['benchmarkcodedecoder', '    ', '    ', ' ', '-27.95'], ['benchmark', '               ', 'old', 'mb', 's', '    ', 'new', 'mb', 's', ' ', 'speedup'], ['benchmarkcodeencoder', '       ', '      ', '   ', '1.38x'], ['benchmarkcodedecoder', '       ', '       ', '   ', '1.39x'], ['hey', 'dave-'], ['that', "'d", 'great', 'add', 'autobench', '-PRON-', 'will', 'interesting', 'raw', 'code', 'vs', 'encode', 'json', "'s", 'reflection', 'base', 'approach', 'improve', 'time'], ['thank'], ['ben'], ['ben--'], ['thank'], ['this', 'timely', 'consider', 'start', 'work'], ['similar', 'package', '-PRON-', 'look', 'forward', 'take', 'spin'], [], ['robert', 'melton'], ['hi', 'everyone-'], ['-PRON-', 'have', 'hit', 'performance', 'bottleneck', 'json', 'encode', 'project', 'sky', 'goraft', '-PRON-', 'write', 'alternative', 'call', 'megajson', '-PRON-', 'notice', 'lot', 'cpu', 'time', 'go', 'reflect', 'package', 'determine', 'appropriate', 'type', 'serialize', 'megajson', 'take', 'approach', 'generate', 'parser', 'ast', 'package', 'compile', 'time'], ['-PRON-', 'be', 'alpha', 'stage', '-PRON-', 'think', '-PRON-', 'would', 'post', 'feedback', 'people', 'approach'], ['use', 'test', 'datum', 'encoding', 'json', 'megajson', 'encode', 'decode', '2x', 'faster', 'obviously', 'ymmv'], ['special', 'shopify', 'sponsor', 'work'], ['ben', 'johnson'], ['bcc', 'dev'], ['if', 'think', 'proto', 'unmarshal(data', 'pb', 'clear', 'old', 'content', 'pb'], ['stop', 'read'], ['the', 'current', 'behavior', 'proto', 'unmarshal(data', 'pb', 'actually', 'write'], ['information', 'datum', 'pb', 'leave', 'untouched', 'old'], ['information', 'explicitly', 'overwrite', 'live'], ['repeat', 'field', 'this', 'consistent', 'protobuf', 'semantic'], ['general', 'people', 'not', 'know', 'for', 'example'], [], ['var', 'pb', 'myproto', 'mymessage'], [], ['pb', 'contain', 'repeat', 'field', 'unmarshal', 'keep', 'append'], ['new', 'value', 'repeat', 'field', 'instead', 'replace', 'entirely', 'or'], ['pb', 'optional', 'field', 'present', 'iteration', 'miss'], ['second', 'iteration', 'second', 'use(&pb', 'field'], ['iteration', 'the', 'safe', 'way', 'reuse', 'pb'], ['var', 'pb', 'myproto', 'mymessage'], [], ['since', 'people', 'unaware', 'property', 'unmarshal', 'code'], ['reuse', 'message', 'reset', 'lead', 'memory', 'leak'], ['incorrect', 'behavior', 'to', 'address', '-PRON-', 'change', 'unmarshal'], ['reset', 'actual', 'unmarshalling'], ['if', 'know', 'unmarshal', 'behave', 'way', 'write', 'code', 'depend'], ['append', 'semantic', 'change', 'code', 'use'], ['proto', 'unmarshalappend'], ['thank'], ['dave'], ['the', 'problem', 'approach', 'c', 'code', 'retain', 'pointer'], ['go', "'s", 'gc', 'will', 'not'], ['garbage', 'collect'], ['of', 'course', 'be', 'sure', 'c', 'code', 'will', 'not', 'pointer', 'approach'], ['work', 'fine'], ['-PRON-', 'miss', 'point', '-PRON-', 'apologize', '-PRON-', 'be', 'dense', 'but', '-PRON-', 'think'], ['clean', 'way'], ['-PRON-', 'example', 'code', 'get', 'little', 'long', '-PRON-', 'be', 'possible', 'use', 'malloc'], ['cast', 'pointer', 'unsafe', 'sizeof', 'help', 'determine', 'size'], ['structure', 'but', 'far', 'easy', 'way', 'imo'], ['let', 'allocate', 'structure', 'c'], ['-PRON-', 'respectfully', 'suggest', 'be', 'think', 'take', 'advantage', "'s"], ['awesomeness', 'treat', 'like', 'normal', 'struct'], ['=', 'c.struct_student'], ['sizeof', 'operator', 'function', '-PRON-', 'not', 'think', 'use'], ['directly', 'like', '-PRON-', 'use'], ['c.size_t(unsafe', 'sizeof(c.struct_student'], ['<', 'robert.s...@gmail.com', '>', 'write'], [], ['matt', 'kane', "'s", 'brain'], ['try', '-PRON-', 'not', 'think', 'gc', 'collect', 'memory'], ['<', 'robert.s...@gmail.com', '>', 'write'], [], ['matt', 'kane', "'s", 'brain'], ['<', 'robert.s...@gmail.com>wrote'], ['not', '-PRON-', 'know', ' ', 'usually', 'not', 'sense', 'point', 'cgo'], ['interoperability', 'exist', 'code', 'imply', 'be'], ['write', 'c', 'interoperate', 'exist', 'go'], ['what', 'gdb'], ['jsing', 'commit', 'fix', 'today', 'hg', 'pull', '-u', 'update'], ['yeah', 'sorry', '-PRON-', 'not', 'place'], ['kr'], ['connect', 'dot'], ['what', 'make', 'public', 'accomplish', ' ', 'can', 'not', 'return', 'error'], ['message', 'code'], ['just', 'guess', 'be', 'catch', 'error', 'return'], ['err', '=', '=', 'requestbodytoolarge', ' '], ['-PRON-', 'be', 'maxbytesreader', '-PRON-', 'would', 'like', 'return'], ['status', 'status', 'client', 'depend'], ['limit', 'reach', 'error'], ['happen'], ['how', 'make', 'error', 'new("http', 'request', 'body', 'large'], ['public', 'variable', 'package'], ['kr'], ['hi'], ['-PRON-', 'build', 'gdb', 'python', 'support', 'windows', '32bit', '64bit'], ['python2.6', 'amd64'], ['python', 'x86', 'work', 'runtime-gdb.py'], ['gdb', 'window', 'crash', 'auto', 'load', 'script', 'source', 'command'], ['crash', '-PRON-', 'not', 'time', 'digg', 'need', 'disable', 'auto', 'load'], ['script', 'runtime-gdb.py', 'work', 'runtime-gdb.py', 'create'], ['.gdbinit', 'file', 'want', 'debug', 'program', "'s", 'folder', 'content'], ['set', 'auto', 'load', 'script'], ['python', 'execfile("runtime', 'gdb.py'], ['enjoy'], [], ['wei', 'guangjing'], ['oops', 'wonder', 'copy', 'paste', 'fix'], [], ['gustavo', 'niemeyer'], ['-PRON-', 'be', 'absolutely', 'sure'], ['hey'], ['in', 'case', 'be', 'bazaar', 'vcs', 'have', 'likely', 'stumble'], ['problem', 'try', 'usual', 'workflow', 'work', '$', 'gopath'], ['new', 'tool'], [], ['gustavo', 'niemeyer'], ['-PRON-', 'be', 'absolutely', 'sure'], ['openmail.co', 'hire', 'go', 'engineer', 'venice', 'ca', 'half', 'block'], ['beach', '-PRON-', 'base', 'los', 'angeles', 'area', 'willing'], ['will', 'fly', 'interview', 'pay', 'relocation', 'expense'], ['-PRON-', 'be', 'solve', 'fundamentally', 'interesting', 'problem', 'relate', 'discovery'], ['communication'], ['the', 'technical', 'team', 'small', 'distribute', 'eng', 'la'], ['future', 'hiring', 'la'], ['-PRON-', 'financial', 'extraordinary', 'company', 'age', 'size', '$', '20m+'], ['revenue', 'strong', 'margin'], ['-PRON-', 'write', 'go', 'day'], ['-john', 'fries'], ['jfr...@openmail.co'], ['hi', 'guy'], ['-PRON-', 'be', 'hunt', 'go', 'engineer', 'san', 'francisco', 'bay', 'area', 'yes'], ['local', 'unfortunately', 'let', 'know', 'be'], ['interested'], ['backend', 'engineer', 'go'], ['san', 'francisco', 'ca'], ['join', 'lead', 'go', 'company', 'world', 'help', 'build'], ['generation', 'high', 'scale', 'high', 'performance', 'cloud', 'service', '-PRON-', 'be', 'look'], ['new', 'go', 'developer', 'join', 'san', 'francisco', 'team', 'work', 'directly'], ['cto', 'co', 'founder'], ['-PRON-'], ['write', 'go'], ['write', 'go'], ['write', 'blog', 'post', 'write', 'go'], ['write', 'go'], ['help', 'organize', 'gosf', 'the', 'world', 'large', 'go', 'meetup'], ['ps', 'sorry', 'spam', 'unless', 'course', 'look', 'job'], ['spam', 'be', 'welcome'], ['travis'], ['thank', 'ross', '-PRON-', 'will', 'try', 'and', 'code', '-PRON-', 'would', 'like'], ['these', 'function', 'usually', 'return', 'multiple', 'value', 'error', 'nil', 'error', 'happen', 'check'], ['assume', 'normal', 'mime', 'multipart', 'response', 'matter'], ['parse', 'content', 'type', 'header', 'find', 'boundary', 'pass'], ['newreader', 'mime', 'multipart', 'package'], ['-PRON-', 'go', 'exactly', 'pipe', 'image', 'opencv'], ['ross', 'light', '|', 'software', 'engineer', '|', 'li...@google.com'], ['hi'], ['-PRON-', 'manage', 'stream', 'byte', 'byte', 'ad', 'come', '-PRON-', 'miss', 'piece', '-PRON-', 'not', 'use', 'reader', 'nextpart', '-PRON-', 'not', 'correctly', ' ', 'build', 'multipart', 'newreader', '-PRON-', 'error', 'like', 'multiple', 'value', 'single', 'value', 'context'], ['any', 'clue'], ['thank'], ['teo'], ['the', 'compilation', 'error', 'connect', 'want', 'pointer', 'do', 'instead'], ['sa', '=', 'unix', 'sockaddrinet4'], ['michael', 'jones'], ['michae...@gmail.com'], ['oh', '-PRON-', 'successfully', 'compile', 'code', 'darwin', 'linux', ' ', 'thank'], [], [], ['kinoshita', 'minoru'], ['kinoshita...@gmail.com'], ['2016年6月28日(火', '1:17', 'michael', 'jones', '<', 'michae...@gmail.com', '>'], ['there', 'escape', 'rune', 'csv', 'package', 'internal', ' ', 'there'], ['quote', 'double', 'quote', 'quote', 'value', ' ', 'the'], ['special', 'character'], ['the', 'separator', 'default'], ['the', 'quote'], ['the', 'lead', 'comment', 'character', 'default'], ['the', 'newline', 'character', '\\n'], ['the', 'carriage', 'return', 'character', '\\r'], ['whitespace', 'unicode', 'isspace'], ['-PRON-', 'point', 'ability', 'use', 'time'], ['draw', 'line', 'line', ' ', 'quoting', 'complicated'], ['csv', 'reader', ' ', 'as', '-PRON-', 'say', 'earlier', 'make', 'quote', 'character'], ['configurable', 'easy', 'change', 'line', 'add', 'line', '+', 'comment', '+'], ['test', 'break', 'backward', 'compatibility', ' ', 'the', 'issue'], ['line', 'draw', 'standard', 'library', ' ', '-PRON-', 'draw', 'line'], ['perhaps', 'use', 'proposal', 'process', 'propose', 'change'], ['change', 'easy', '\n    ', '-paul'], ['there', 'different', 'variant', 'csv', ' ', '-PRON-', 'not'], ['support', 'produce', 'horrible', 'frankenstein', "'s", 'monster'], ['package', ' ', '-PRON-', 'copy', 'encoding', 'csv', 'source'], ['code', 'adjust', 'need'], ['ian'], ['-PRON-', 'appear', 'declare', 'constitute', 'quote', 'not', 'possible', '-PRON-', 'be', 'work'], ['datum', 'publish', 'usda', 'use', 'tilde', 'quote', 'field'], ['field', 'contain', 'actual', 'quote', 'enforce', 'set', 'number', 'field'], ['record', 'set', 'lazyquotes', '=', 'true', 'appear', 'work', 'surface'], ['level', '-PRON-', 'not', 'inspect', 'actual', 'datum'], ['guarantee', 'datum', 'intact', 'intend'], ['be', 'declare', 'constitute', 'quote', 'csv', 'reader', 'comma'], ['desirable', 'csv', 'package', 'in', 'case', 'clear'], ['well', 'be', 'concern', 'one', 'continue', 'null'], ['value', 'independent', 'concern', '-PRON-', 'not', 'think', 'be'], ['slippery', 'slope', 'feature', 'necessarily', 'interdependent'], ['particular', 'change', 'question', 'expose', 'wide', 'variety', 'format', 'support'], ['create', 'frankenstein', 'fit', 'current', 'framework'], ['if', 'concern', 'request', 'pour', 'support', 'arbitrary'], ['functionality', 'not', 'fit', 'current', 'work'], ['prepare', 'respond', 'appropriately', 'request', 'sound'], ['csv', 'probably', 'not', 'std', 'lib', 'either', 'way'], ['-PRON-', 'credit', 'author', 'say', 'change', 'likely', 'will', 'not'], ['accept', 'be', 'ok'], ['after', 'read', 'rfc', 'appear', 'package', 'csv', 'be'], ['suggest', 'be', 'case', 'rfc'], ['guide', 'principal'], ['as', 'far', 'usda', 'data', 'behavior', 'circumstance'], ['not', 'exist', 'take', 'doc'], ['ascii', 'file', 'delimit', 'all', 'field', 'separate', 'caret', '^', 'text'], ['field', 'surround', 'tilde', '~', 'a', 'double', 'caret', '^^', 'caret'], ['tilde', '~~', 'appear', 'field', 'null', 'blank'], ['somewhat', 'related', '-PRON-', 'happen', 'tilde', 'usage'], ['-PRON-', 'suppose', 'point', '-PRON-', 'will', 'probably', 'opt', 'sort', 'line'], ['scanner'], ['-PRON-', 'think', 'be', 'clear', 'silence', 'value', 'contain', '~', 'consider'], ['invalid', 'these', 'type', 'case', 'not', 'complication', 'view', '~'], ['narrower', 'csv', 'parser', 'in', 'future'], ['decide', '~this', '~', 'valid~^', 'single', 'field', 'stop'], ['name', 'datum', 'dump', 'csv', 'extension'], ['-PRON-', 'write', 'the', 'word', 'do', 'not'], ['no', 'a', 'field', 'quote', 'give', 'rune', 'categorization', 'set'], ['rune', 'quote', 'character', 'writing', 'irrelevant', '-PRON-', 'be'], ['personally', 'aware', 'possible', 'csv', 'parser', '-PRON-', 'have'], ['see', 'datum', 'like', 'be', 'excel'], ['if', '-PRON-', 'think', 'question', 'not', 'csv', 'package'], ['allow', 'set', 'escape', 'rune', 'common', 'setting'], ['-PRON-', 'be', 'de', 'facto', 'standard', 'example'], ['change', 'easy'], ['-PRON-', 'will', 'consider'], ['the', 'rfc', 'guide', 'principle', ' ', '-PRON-', 'assure', ' ', 'yes', 'csv'], ['package', 'handle', 'particular', 'ability'], ['variable', 'number', 'field', 'record', 'ability', 'comment'], ['handling', 'white', 'space', ' ', 'all', 'relatively', 'common', 'situation', '\n ', 'the', 'white', 'space', 'handling', 'excel', 'remove', 'lead', 'white'], ['space'], ['the', 'usda', 'spec', 'silent', 'datum', '~'], ['clear', '~', 'start', 'end'], ['field', ' ', '-PRON-', 'note', 'usda', 'spec', 'use', '^', 'delimiter'], ['the', 'csv', 'package', 'handle', 'link'], ['use', '~', 'instead', 'separate', 'field', 'record'], ['-PRON-', 'agree', 'easy', 'quote', 'character', 'settable'], ['beg', 'question', 'csv', 'package', 'not', 'handle'], ['different', 'quoting', 'mechanism', '  ', 'should', 'able', 'handle', 'different'], ['quote', 'character', 'like', ' ', '-PRON-', 'write', 'the', 'word'], ['do', 'not', '-PRON-', 'not', 'modify', 'csv', 'package'], ['point', 'get', 'standard', 'library', '\n    ', '-paul'], ['-PRON-', 'completely', 'understand', 'point', 'view', 'csv', 'spec'], ['but', 'rabbit', 'hole', 'suggest', 'configurable', 'quote'], ['for', 'example', 'datum', 'originally', 'import', 'directly', 'postgre'], ['define', 'delimiter', 'quote', 'character', 'while', 'be', 'unfortunate'], ['current', 'api', 'use', 'comma', 'define', 'field', 'delimiter', 'be'], ['appear', 'prohibitive', 'define', 'quote', 'character'], ['in', 'case', '-PRON-', 'benefit', 'the', 'ad', 'hoc', 'defining', 'factor'], ['delimited', 'field', 'define', 'give', 'rune', 'contain', 'field'], ['delimiter', 'without', 'thought', 'give', 'circumstance'], ['depth', 'review', 'code', '-PRON-', 'be', 'fairly', 'certain', 'not', 'introduce'], ['strange', 'complex', 'behavior', 'if', 'like'], ['fix', 'regardless'], ['thank', 'input', 'ian'], ['as', 'person', 'write', 'package', 'csv', 'convince', 'russ', 'include', '-PRON-'], ['research', 'csv', 'format', '  ', '-PRON-', 'not', 'believe', '-PRON-', 'find', 'standard'], ['double', 'quote', 'quote', ' ', 'unlike'], ['option', 'quote', 'simple', 'quote', 'character', ' ', 'the', 'problem'], ['come', 'quote', 'character', 'inside', 'value', ' ', 'there', 'multiple'], ['way', 'people', 'include', 'space', 'easy', 'read'], [' ', 'the', 'rfc', 'say', 'escape', 'double', 'quote'], ['list', ' ', 'note', 'mean', 'go', "'s", 'quoting', 'q', 'valid'], ['csv', 'parser', ' ', 'what', 'usda', 'value', 'contain', '~'], ['character'], ['russ', 'inclined', 'include', 'package', 'csv', 'mainly', 'lack'], ['standard', ' ', 'russ', 'agree', 'let', '-PRON-', 'able', 'point', 'rfc'], ['\n    ', '-paul'], ['read', 'mean', 'add', 'escape', 'character', 'default'], ['quote', 'character', ' ', 'this', 'slippery', 'slope', 'question'], ['safety', 'net', 'stop', 'slide', ' ', 'ian', 'indicate'], ['hit', 'safety', 'net', '\n    ', '-paul'], ['<', 'philipp....@gmail.com', '>', 'write'], ['-PRON-', 'not', 'know', 'doc'], ['compare', 'tip', 'gc', 'run', 'parallel', 'fast', ' ', '-PRON-'], ['accurate', 'type', 'information', 'prone', 'e.g.'], ['treat', 'float', 'value', 'pointer', ' ', '-PRON-', 'possible'], ['release', 'fully', 'precise', 'currently', '-PRON-', 'believe'], ['precise', 'heap', 'value', 'stack', 'value'], ['however', 'gc', 'remain', 'mark', 'sweep', 'collector', ' ', '-PRON-'], ['incremental', 'generational', 'value'], ['-PRON-', 'clear', 'continue', 'good', 'idea', 'use', 'pool'], ['custom', 'allocator', 'datum', 'structure', 'use', 'lot', 'memory', ' ', 'work'], ['continue', 'gc', 'release'], ['ian'], ['be', 'sure', 'work'], ['string', 'string', 'equal', 'content', 'indistinguishable'], ['be', 'locate', 'different', 'part', 'memory'], ['non', 'heap', 'allocate', 'object', 'object', 'large', 'bit'], ['allocate', 'heap', 'value', 'type', 'complex128'], ['unique', 'number', 'change', 'time', 'value', 'copy'], ['happen', 'go', 'change', 'allow', 'equality', 'testing'], ['struct', 'value', 'hope', 'happen', 'time'], ['-PRON-', 'not', '-PRON-', 'would', 'demand', 'thing', 'want', 'set'], ['satisfy', 'non', 'interface', 'eg', 'prejudice', 'hash'], ['equality', 'method'], ['chris'], [], ['chris', 'allusive', 'dollin'], ['map[interface]bool'], [], ['russ'], ['-PRON-', 'agree', 'int64', 'lot', 'space', 'overhead'], ['-PRON-', 'not', 'agree', 'equal', 'thing', 'equal', 'hash', '-PRON-'], ['propose', 'hash', '-PRON-', 'number', 'distinguish', 'object', 'value'], ['p'], ['demand', 'equality', 'reasonable', 'demand', 'hashing'], ['hashing', 'i.e.', 'numbering', 'object', 'necessarily'], ['natural', 'mathematical', 'meaning', 'convenience', 'implementation', 'thing'], ['compiler', 'support', 'here', 'be'], ['autoincrement', 'counter'], ['drag', 'programmer', 'object', 'this'], ['implement'], ['transparently', 'set', 'datum', 'structure', 'library'], ['way', 'library'], ['distinguishing', 'object', 'pointer'], ['unchanging', 'so', 'programmer'], ['use', 'custom', 'method'], ['-PRON-', 'propose', 'go', 'provide', 'method', 'call', 'like', 'objectid'], [], ['return', 'int64', 'unique', 'object', 'system'], ['in', 'current'], ['implementation', 'pointer', 'object', 'but'], ['later', 'go'], ['folk', 'decide', 'implement', 'copying', 'gc', 'change', 'language'], ['autoincrement', 'counter', 'struct'], ['p'], ['thanks', 'russ', 'this'], ['although', 'reference', 'scenario'], ['capture', 'suggestion'], ['imagine', 'want', 'maintain', 'membership', 'product', 'set'], ['object', 'i.e.', 'axa', 'if', 'set', 'sparse', 'data', 'structure'], ['map[interface]map[interface]bool'], [], ['p'], ['wonder', 'complicate', 'fact'], ['pointer', 'point', 'middle', 'heap', 'object'], ['could', 'leave', 'use', 'map'], ['that', 'be', '-PRON-', 'dynamic', 'language', 'implementation', '\n ', 'but', 'probably', 'rely', 'know', 'thread-', '\n ', 'like', 'thing', 'go', 'way', 'gc', 'not', '\n ', 'happen', 'accessor', 'updater', 'work', '\n ', 'map'], ['chris'], [], ['chris', 'allusive', 'dollin'], ['-PRON-', 'not', 'language', 'specification', 'explicitly'], ['guarantee', 'current', 'implementation'], ['safe', 'assume', 'pointer', 'not', 'change'], ['-PRON-', 'suppose', 'be', 'possible', 'write', 'copying', 'garbage'], ['collector', 'point'], ['evan'], ['hi'], ['-PRON-', 'be', 'contemplate', 'pointer', 'object', 'hash', 'code'], ['placement'], ['hashtable', 'so', 'pointer', 'guarantee', 'stay', 'unchanged'], [], ['life', 'object'], ['thank'], ['--petar'], ['-PRON-', 'feeling', 'raise', 'issue', 'language', 'design'], ['if', 'agree', 'language', 'able'], ['implement', 'set', 'membership', 'datum', 'structure', 'entry'], ['interface', 'question', 'simply', 'stand'], ['how', 'go', 'rest', 'hope'], ['garbage', 'collector', 'will', 'not', 'object', 'future', 'matter'], [], ['unsafe', 'package'], ['--petar'], ['-PRON-', 'not', 'think', 'work', 'mean', 'be', 'extra'], ['overhead', 'int64', 'pretty', 'struct', 'struct'], ['struct', 'nest', 'overhead'], ['also', 'equal', 'thing', 'equal', 'hash', 'scheme'], ['not', 'satisfy'], ['chris'], [], ['chris', 'allusive', 'dollin'], ['-PRON-', 'not', 'language', 'implement'], ['type', 'need'], ['the', 'current', 'implementation', 'object'], ['there', 'be', 'language', 'spec', 'prohibit'], ['future', 'implementation', 'object'], ['be', 'write', 'code', 'today', 'be', 'reasonably', 'safe', 'bet'], ['object', 'will', 'not'], ['add', 'ian', 'say', 'update', 'pointer'], ['middle', 'object', 'easy', ' ', 'a', 'annoying'], ['complication', 'have', 'rehash', 'map[*foo]bar'], ['russ'], ['roger', 'peppe', '<', 'rogp...@gmail.com', '>', 'write'], ['a', 'copying', 'garbage', 'collector', 'able', 'reliably', 'locate'], ['pointer', ' ', 'give', 'adjust', 'pointer', 'middle', 'object'], ['harder', 'adjust', 'pointer', 'start', 'object'], ['-PRON-', 'not', 'know', 'current', 'plan', 'actually', 'implement', 'copying'], ['garbage', 'collector'], ['ian'], ['real', 'code', 'panic', 'response'], ['error', 'return', 'will', 'handle', 'way'], ['real', 'code', 'not', 'feature', 'carry', 'weight'], ['write', 'quick', 'little', 'program', 'will', 'usually'], ['helper', 'function', 'instance', '\n   ', 'f', 'err', '=', 'foo', 'bar(x', '\n   ', 'check(err', 'bar', 'q', 'x'], ['way', 'error', 'message', 'come', 'appropriate', 'context'], ['tell', 'value', 'x', 'call', 'bar'], ['save', 'see', 'large', 'stack', 'trace', 'rarely'], ['want', 'situation', 'want', 'program', 'stop'], ['go', 'wrong'], ['not', 'want', 'use', 'feature', 'throwaway', 'program'], ['if', 'tired', 'read', 'feature', 'proposal', 'stop', 'read', 'else'], ['use', 'fix', 'width', 'font', 'good', 'reading', 'experience'], ['panicky', 'assigned', 'values'], ['=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '=', '='], ['a', 'panicky', 'assigned', 'value', 'value', 'assign', '=', '='], ['cause', 'program', 'panic', 'value', 'nil', '-PRON-'], ['generally', 'apply', 'error', 'return', 'func', 'unfortunately'], ['-PRON-', 'find', 'way', 'cleanly', 'implement', 'feature', 'current'], ['go', 'syntax', 'proposal'], ['just', 'like', 'blank', 'identifier', 'allow', 'indicate', 'unused', 'assign'], ['value', 'panicky', 'identifier', 'allow', 'indicate', 'panicky'], ['value', 'more', 'precisely', 'line'], ['=', 'somefunc'], ['be', 'equivalent'], ['err', '=', 'somefunc'], ['err', '=', 'nil'], ['the', 'propose', 'syntax', 'concise', 'clean', 'explicit', 'useful'], ['situation'], ['motivation'], ['=', '=', '=', '=', '=', '=', '=', '=', '=', '='], ['in', 'text', 'error', 'mean', 'intermittent', 'environmental', 'error'], ['lose', 'network', 'connection', 'memory', 'disk', 'space', '-PRON-'], ['mean', 'programmer', 'error', 'bug'], ['by', 'convention', 'error', 'return', 'return', 'value'], ['function', 'there', 'thing', 'developer', 'error'], ['ignore', 'handle'], ['this', 'ignore', 'error'], ['=', 'somefunc'], ['this', 'handle', 'error'], ['err', '=', 'somefunc'], ['err', '=', 'nil'], ['in', 'practice', 'rarely', 'want', 'ignore', 'error', 'most', 'want'], ['program', 'handle', 'error', 'the', 'popular', 'choice', 'halt'], ['program', 'routine', 'request', 'handler', 'pass', 'error'], ['stack', 'caller', 'finally', 'recover', 'error', 'e.g.'], ['renew', 'network', 'connection', 'try', 'in', 'complex', 'case'], ['combination'], ['in', 'complex', 'fast', 'pace', 'release', 'early', 'release', 'software'], ['development', 'environment', 'e.g.', 'web', 'app', 'common', 'start'], ['halt', 'program', 'reaction', 'intermittent', 'error', 'project'], ['mature', 'gradually', 'add', 'proper', 'error', 'handle'], ['robust', 'by', 'gain', 'knowledge', 'system', 'include'], ['error', 'handle', 'in', 'beginning', 'halt'], ['error', 'safe', 'lazy', 'choice', 'a', 'non', 'robust', 'program', 'useful'], ['good', 'early', 'stage', 'team', 'small'], ['feature', 'algorithm', 'correctness', 'important'], ['robustness', 'performance', 'etc', '-PRON-', 'not', 'want', 'stick', 'premature'], ['optimization', '-PRON-', 'premature', 'productization'], ['more', 'importantly', 'case', 'halt', 'program', 'certain', 'error'], ['desire', 'behavior', 'in', 'case', 'statement'], ['error', 'noise'], ['unfortunately', 'concise', 'lazy', 'release', 'early-'], ['release', 'friendly', 'syntax', 'available', 'ignore', 'error'], ['safe', 'choice', 'early', 'stage', 'project', 'this'], ['motivate', 'come', 'similarly', 'easy', 'syntax', 'halt'], ['program', 'error', 'detect', 'without', 'developer'], ['incentiviz', 'ignore', 'error', 'waste', 'time', 'premature'], ['productization', 'and/or', 'pollute', 'code', 'boilerplate'], ['look', 'mailing', 'list', 'drop', 'error'], ['instead', 'handle', 'common', 'mistake'], ['people', 'to', 'mind', 'provide', 'implicit', 'panic'], ['harmful', '-PRON-', 'probably', 'standard', 'handling'], ['error', 'people', 'stop', 'actually', 'think', 'possible', 'error'], ['go', 'to', 'handle', 'this', 'result', 'program'], ['panic', 'tiny', 'error', 'handle', 'clean'], ['way'], ['-PRON-', 'sure', 'idea', 'useful', 'people', 'know'], ['deal', 'describe', 'early', 'stage', 'but'], ['people', 'know', 'want', 'know', 'lazy'], ['moment', 'want', 'add', 'correct', 'error', 'handle', 'later', 'later'], ['go', 'happen', 'end', 'bunch', 'constantly'], ['panicing', 'program'], ['for', 'early', 'stage', 'development', 'simple', 'script'], ['search&replace', 'suggest', 'affect'], ['language'], ['2011/12/8', 'peter', 'bourgon', '<', 'peterb...@gmail.com', '>'], ['as', 'point', 'way', 'concisely', 'declare'], ['non', 'nil', 'error', 'panic', ' ', 'whether', 'verbose', 'route', 'propose'], ['simple', 'chk(os', 'error', 'function', ' ', 'as', 'go'], ['tool', 'use', 'wish'], ['and', 'develop', 'feature', 'quickly', 'iterate', 'rapidly', ' ', '-PRON-', 'find', 'error'], ['check', 'absolutely', 'essential', 'task', ' ', 'while', '-PRON-', 'return'], ['error', '-PRON-', 'find', '-PRON-', 'print', 'fire'], ['monitoring', 'solution', ' ', 'this', 'short', 'circuit', 'lot', 'debug', '-PRON-'], ['because', 'error', 'later', 'fact', 'not'], ['panic', 'allow', 'continue'], ['completely', 'fall', 'require', 'code', 'change', 'proceed'], ['yegor', 'write'], ['panic', 'eventually', 'get', 'replace', 'actual', 'error', 'handling', 'the'], ['conditional', 'branch', 'error', 'case', ' ', 'when', 'replace', 'panic'], ['proper', 'error', 'handle', 'branch', 'code', 'write'], ['eventually', 'place', 'why', 'use', 'mechanism'], ['replace'], ['checking', 'error', 'explicit', 'feel', 'natural', 'programmer'], ['familiar', 'go', 'proposal', 'propose'], ['explicit', 'sense', 'programmer', 'express', 'intent'], ['cryptic', 'incomprehensible', 'programmer', 'familiar'], ['language', 'feature', 'while', 'code', 'short', '-PRON-', 'feel'], ['weight', 'page'], ['in', 'case', '-PRON-', 'think', 'conditional', 'noise', 'good'], ['thing', 'if', 'want', 'panic', 'panic', 'be', 'decision'], ['compiler', "'s", 'do', 'not', 'hide', 'inside', 'cryptic', 'statement', 'clear'], ['visible', 'reader'], [], ['aram', 'hăvărneanu'], ['just', 'clarify', 'accord', 'proposal'], ['-PRON-', 'find', 'explicit', '-PRON-', 'know', 'run', 'program'], ['behave', 'the', 'problem', 'implicit', 'compile', 'time', 'ambiguity'], ['e.g.', 'language', 'mistakenly', 'add', 'float', 'int'], ['compiler', 'automatically', 'perform', 'type', 'conversion', 'instead', 'fail'], ['compilation'], ['-PRON-', 'train', 'people', 'handle', 'error', 'properly', 'simply'], ['panic', ' ', 'that', 'sound', 'like', 'exception', ' ', 'if', 'take'], ['get', 'bite', 'time', 'ignore', 'error', 'return', '-PRON-'], ['think', 'be', 'overall', 'win'], ['~k'], ['yegor', 'write'], ['of', 'course', 'mention', 'people', 'panic', 'prototype', 'code'], ['replace', 'code', 'proper', 'error', 'handle', 'later', ' ', '-PRON-', 'respond'], ['context'], ['typing', 'extra', 'line', 'code', 'time', ' ', 'in'], ['experience', '-PRON-', 'spend', 'significant', 'time', 'typing', 'code', 'compare'], ['programming', 'task', 'like', 'think', 'thing', 'read', 'code'], ['analyze', 'code', 'work', 'debugging', 'etc'], ['even', 'not', 'know', 'read', 'code', 'use'], ['understand', ' ', 'on', 'hand', 'effect'], ['reader', 'need', 'aware'], ['in', 'experience', 'people', 'want', 'ignore', 'error', 'language', 'feature'], ['stop', ' ', 'too', 'people', 'add', 'catch', 'clause', 'java', 'stop'], ['program', 'crash', 'catch'], ['the', 'syntax', 'ignore', 'error', 'exist', 'today', ' ', 'if', 'people', 'choose'], ['abuse', 'feature', 'will', 'not', 'stop'], ['in', 'opinion', 'context', 'reader', 'need', 'understand'], ['good', ' ', 'the', 'code', 'tell', 'reader', 'exactly'], [' ', '-PRON-', 'fan', 'syntactic', 'shortcut', 'magic', 'language'], ['feature'], ['every', 'syntactic', 'idiom', 'language', 'burden', 'great', 'weight'], ['shoulder', 'reader', ' ', '-PRON-', 'trade'], ['expressiveness', 'utility', 'clarity', ' ', '-PRON-', 'feel', 'go', 'make', 'trade'], ['better', 'language', '-PRON-', 'work', ' ', '-PRON-', 'feel'], ['add', 'alternative', 'syntax', 'add', 'expressiveness', 'tip'], ['balance', 'go', 'strive'], ['because', 'go', 'code', 'straightforward', 'explicit', 'lack', 'syntactic'], ['sugar', 'reading', 'answer', 'question', 'easy'], ['then', 'not', 'panic', 'code', 'clear', ' ', '-PRON-', 'believe', 'error', 'handling'], ['algorithm', 'clear', 'code'], ['proper', 'error', 'handling', ' ', '-PRON-', 'think', 'write', 'error', 'handling'], ['sacrifice', 'readability', 'code'], ['go', 'concise', 'language', 'industry', 'today', ' ', '-PRON-'], ['disagree', 'promote', 'error', 'ignorance', 'be', 'case'], ['not', 'change', ' ', 'people', 'abuse'], ['inclined'], ['conciseness', 'virtue', 'clarity', ' ', '-PRON-', 'relate', 'be'], ['linear', 'relationship', ' ', '-PRON-', 'think', 'go', 'succeed', 'maximize', 'clarity'], [], ['aram', 'hăvărneanu'], ['or', 'write', 'go', 'standard', 'style', 'grow', 'if'], ['write', 'line', 'code', 'find'], ['unbearable', 'come'], ['dave'], ['-PRON-', 'have', 'mention', 'problem', 'language'], ['-PRON-', 'be', 'tedious', 'write', 'error', 'handle', 'code'], ['-PRON-', 'be', 'easy', 'ignore', 'error'], ['-PRON-', 'happen', 'agree', '-PRON-', 'think', 'thing', 'flaw'], ['language'], ['-PRON-', 'fantastiz', 'solution', 'build', 'if', 'f', 'function'], ['return', 'type', 'error', 'must(f', 'panic'], ['error', 'non', 'nil', 'return', 'return', 'value', 'omit'], ['error', 'e.g.', 'instead'], ['n', 'err', '=', 'w', 'write(byte'], ['err', '=', 'nil'], ['write'], ['n', '=', 'must(w', 'write(bytes'], ['-PRON-', 'not', 'think', 'will', 'build', 'someday'], ['write', 'smart', 'macro', 'system', 'go', 'understand'], ['type', 'write'], ['anyway', 'think', 'let', 'separate', 'semantic'], ['proposal', 'syntax', 'syntax'], ['semantic', 'ordinary', '-PRON-', 'not', 'write', 'go', 'solely'], ['type', 'reason'], ['-PRON-', 'add', '-PRON-', 'personally', 'use', 'initial'], ['prototyping', 'pedagogical', 'code', '-PRON-', 'hate', 'code', 'omit', 'error', 'checking'], ['clarity', 'rare', 'case', 'panic'], ['right', 'thing', '-PRON-', 'believe', 'time', 'not'], ['for', 'problem', 'be', 'easy', 'write'], ['f(x'], ['f', 'return', 'error', '-PRON-', 'language', 'y', 'solution', 'tool-'], ['y', 'fallback', '-PRON-', 'wish', 'way', 'annotate', 'function', 'return', 'value'], ['compiler', 'error', 'caller', 'ignore', 'gnu', 'c'], ['+', '+', 'like', 'extension', '-PRON-', 'happen', 'like'], ['callers', 'ignore', 'error', 'wish', 'write'], ['=', 'f(x'], ['would', 'way', 'note', 'proposal'], ['return', 'value', 'type', 'error', 'ignore', 'non-'], ['error', 'return', 'value', 'important', 'check', 'error', 'return'], ['value'], ['since', 'be', 'go', 'language', 'discussion'], ['fallback', 'tool', 'like', 'govet', 'find'], ['situation', 'warn'], ['tl;dr', 'suitable', 'tooling', 'nyi', 'go', 'error', 'handle'], ['behavior', 'want'], ['-PRON-', 'have', 'realize', 'solution', 'suck', 'big', 'time', '-PRON-', 'keep', 'assume'], ['return', 'value', 'assign', 'what', 'a'], ['demo'], ['=', 'foo'], ['=', 'foo'], ['-PRON-', 'will', 'start'], ['yegor'], ['not', 'true', 'there', 'ton', 'wonderful', 'java', 'c++', 'program'], ['robust', 'be', 'possible', 'not'], ['constantly', 'panic', '-PRON-', 'create', 'great', 'program'], ['language', 'suck'], ['ignoring', 'error', 'bad', 'idea', 'early', 'stage'], ['project', 'a', 'compiler', 'warning'], ['$', 'cat', '`', 'find', '|', 'grep', '.go$', '`', '|', 'wc', '-l'], [], ['folder'], [], ['so', 'line', 'far', 'a', 'lot', 'tinker', 'solution'], ['projecteuler.net', 'problem', 'simple', 'algorithm', 'small', 'app', 'engine'], ['app', 'so', 'far', '-PRON-', 'love', 'go', 'error', 'handling', '-PRON-', 'not'], ['think', 'be', 'safe', '-PRON-', 'know', 'tutorial', 'blog', 'discussion'], ['fill', 'information', 'go', 'error', 'handling', 'but', 'huge'], ['information', 'topic', 'indicate', 'problem'], ['-PRON-', 'app', 'developer', 'a', 'lot', 'advice', 'come', 'system'], ['people', 'go', 'start', 'system', 'programming', 'language', 'the', 'app'], ['programming', 'world', 'little', 'different', 'explain'], ['advice', 'not', 'convincing', 'with', 'app', 'deal', 'business'], ['people', 'deadline', 'ambiguity', 'the', 'development', 'process', 'structure'], ['differently', '-PRON-', 'sacrifice', 'robustness', 'performance'], ['know', 'app', 'suppose', 'app'], ['production', 'so', '-PRON-', 'need', 'safe', 'error', 'handling', 'mechanism'], ['-PRON-', 'optimistic', 'solution', 'suit', 'use-'], ['case', 'rigorous', 'system', 'programmer', 'lazy', 'distracted', 'app'], ['developer', 'like', 'after', 'go', 'app', 'engine', 'go'], ['app', 'system'], ['yegor'], ['who', 'quote', '-PRON-', 'reread', 'proposal', '-PRON-', 'find'], ['word', 'implicit', '-PRON-', 'propose', 'exact', 'opposite'], ['explicit', 'panicky', 'identifier'], ['be', 'kind', 'thing', 'add', 'govet', 'desire'], ['annoying', 'ignore', 'error'], ['fmt', 'printf', 'x', 'close', 'etc'], ['from', 'past', 'conversation', '-PRON-', 'believe', 'consensus', 'panic'], ['appropriate', 'program', 'technical', 'error', 'error'], [], ['christoff...@forsvikgroup.com', '>', 'write'], ['write'], ['a', 'common', 'experience', 'java', 'c++', 'program'], ['what', 'op', 'actually', 'want', 'kind', 'assert', 'statement', 'builtin'], ['function'], ['what', 'useful', 'compiler', 'warning', 'tell'], ['ignore', 'error', 'that', 'easily', 'convert', 'compile'], ['error', 'paranoid', 'although', 'know', 'ignore', 'second', 'value'], ['actually', 'error', 'simple'], ['steve', 'd.'], ['this', 'choose', 'follow', 'different', 'software', 'development'], ['process', 'far', 'not'], ['quick', 'little', 'go', 'program', 'throwaway', 'program'], ['proposal', 'target', 'on', 'contrary', 'target', 'large', 'complex'], ['project', 'final', 'not', 'want'], ['waste', 'time', 'thing', 'like', 'proper', 'error', 'handle', 'component'], ['final', 'product', 'time'], ['not', 'want', 'blindly', 'ignore', 'error', 'when', 'write', 'web-'], ['app', 'priority', 'useful', 'sla', '-PRON-'], ['actually', 'gain', 'decent', 'user', 'base', 'occasional', 'glitch'], ['long', 'corrupt', 'user', 'datum', 'first', 'come', 'feature'], ['come', 'robustness', 'performance'], ['-PRON-', 'be', 'quote', 'coin', 'phrase', 'for', 'explicit'], ['panic', 'mean', 'explicitly', 'panic', 'builtin', '\n  ', 'val', 'err', '=', 'foo(bar', 'err', '=', 'nil'], ['whereas', 'implicit', 'panic', 'mean', 'panic', 'trigger'], ['effect', 'action'], ['-PRON-', 'prefer', 'second', 'but', '-PRON-', 'think', 'reasonable', 'case'], ['-PRON-', 'be', 'see', 'problem', 'maybe', 'be', 'lack', 'sophistication', 'code'], ['in', 'simple', 'interpreter', '-PRON-', 'lot', 'little', 'leaf', 'function'], ['operate', 'stack', 'the', 'export', 'function', 'eval', 'the', 'internal'], ['function', 'stuff', 'like', '\n ', 'x', '=', 'toint(stack', '\n ', 'y', '=', 'toint(stack'], ['bad', 'thing', 'happen', 'course', 'stack'], ['stack', 'value', 'not', 'turn', 'number'], ['now', 'early', 'form', 'code', 'awful', '\n ', 'tos', 'err', '=', 'stack.pop'], ['err'], ['err', '=', 'strconv', 'atoi(tos'], ['err'], ['yuck', 'but', 'couple', 'talk', 'andrew', "'s", 'rob', "'s"], ['change', 'life'], ['so', '-PRON-', 'recover', 'eval', 'follow', 'example', 'andrew', "'s", 'nice'], ['talk', 'function', 'pop', 'toint', 'panic', '-PRON-', 'end'], ['code', 'like'], ['now', 'perfect', 'rule', '-PRON-', 'take', 'away', 'simple'], ['internal', 'function', 'panic'], ['function', 'not', 'panic', 'not', 'err', '=', 'nil'], ['test', 'use', 'internal', 'function', 'panic', 'need'], ['export', 'function', 'recover', 'return', 'error'], ['work'], ['but', 'maybe', 'experience', 'date', 'encompass', 'complex'], ['situation'], ['error', 'handling', 'bad', '-PRON-', 'have', 'write'], ['-PRON-', 'think', 'be', 'good', 'go', 'force', 'people', 'code'], ['think', 'just', '$'], ['ron'], ['<', 'christoff...@forsvikgroup.com', '>', 'write'], ['not', 'concise', 'would', 'wish', 'grepp', 'panic'], ['$', 'goroot', 'src', 'pkg/*/*.go', 'good', 'range', 'example'], ['as', 'idiomatic', 'use', 'recover', 'printer', 'encoding', 'json', 'package'], ['use', 'panic', 'recover', 'simplify', 'error', 'handling'], ['panic', 'recover', 'code', 'relatively', 'straightforward'], ['understand', 'need', 'grok', 'entire', 'package', 'source'], ['not', 'exactly', 'case', 'want', 'panic'], ['because', 'project', 'priority', '-PRON-', 'want', 'feature', 'sla'], ['second', 'and', 'case', 'simply', 'want', 'panic', 'will', 'not'], ['replace'], ['that', 'be', 'nature', 'learn', 'new', 'language', 'go', 'plenty'], ['feature', 'feel', 'pretty', 'alien', 'newcomer', 'plus', 'be'], ['difference', 'line', 'term', 'readability'], ['=', 'foo(bar'], ['=', 'foo(bar'], ['-PRON-', 'be', 'second', 'line', 'safe', 'choice', 'second'], ['return', 'value', 'happen', 'error', '-PRON-', 'not', 'want', 'incentivize'], ['newcomer', 'language', 'ignore', 'error', 'give'], ['convenient', 'syntax'], ['the', 'primary', 'objective', 'frequently', 'travel', 'path'], ['this', 'reader', 'function', "'s", 'code', 'question'], ['how', 'function', 'produce', 'correct', 'result', 'absence'], ['error', 'the', 'second', 'question', 'how', 'function', 'behave'], ['error', 'occur', 'important', 'reader', 'get'], ['answer', 'question', 'if', 'algorithm', 'hide'], ['multiple', 'block', 'error', 'handle', 'code', 'panic'], ['harder', 'reader', 'understand', 'code', 'explicit', 'concise'], ['make', 'code', 'clear', 'visible', 'the', 'current', 'approach'], ['explicit', 'verbose', 'promote', 'error', 'ignorance', 'if', 'go', "'s", 'target'], ['feel', 'like', 'dynamically', 'type', 'language', 'conciseness', 'trait'], ['strive', 'if', 'be', 'goal', 'discourage', 'error', 'ignorance'], ['provide', 'syntax', 'compete', 'ignore', 'error'], ['several', 'problem', 'approach'], ['such', 'function', 'build', 'standard', 'lib'], ['end', 'implement', 'version'], ['the', 'syntax', 'fairly', 'dirty'], ['err', '=', 'func1'], ['maybepanic(err'], ['b', 'err', '=', 'func2'], ['maybepanic(err'], ['c', 'err', '=', 'func3'], ['maybepanic(err'], ['the', 'stack', 'trace', 'point', 'wrong', 'line', 'code'], ['not', 'official', 'people', 'aware', 'option'], ['the', 'must', 'convention', 'use', 'initialize', 'global', 'variable', 'usually', '\n ', '-PRON-', 'be', 'good', 'use', 'non', 'must', 'variant', 'code'], ['-PRON-', 'usually', 'design', 'program', 'error', 'travel', 'stack'], ['point', 'origin', '-PRON-', 'handle', '-PRON-', 'rarely', '-PRON-'], ['actually', 'use', 'panic', 'recover', 'mechanism'], ['for', 'sake', 'discussion', 'good', 'concise'], ['use', 'case', 'panic', 'maybe', 'recover'], ['that', 'major', 'motivator', 'proposal'], ['-PRON-', 'second', 'person', 'label', 'implicit', 'please', 'explain'], ['implicit'], ['-PRON-', 'disagree', 'people', 'fix', 'program', 'crash'], ['identify', 'reason', 'crash', 'come', 'solution'], ['-PRON-', 'see', 'program', 'constantly', 'panic', 'a', 'lot'], ['program', 'hack', 'weekend', 'run', 'ok'], ['yes', 'ignore', 'error', 'early', 'stage', 'option'], ['corrupt', 'datum', 'make', 'program', 'extremely', 'hard'], ['debug', 'program', 'crash', 'way', 'ignore', 'error', 'maybe'], ['system'], ['do', 'think', 'good', 'idea', 'program', 'implicitly', 'panic'], ['panic', 'explicitly', 'call', 'panic', 'this'], ['lot', 'magic', 'cover', 'require'], ['justification'], ['will', 'not', 'comment', ' ', 'usefulness', 'be', 'good', 'idea', ' ', 'misunderstood', 'not', 'think', 'need', 'special', 'syntax', 'tjis', 'write', 'function', ' ', 'take', 'error'], ['a', 'programming', 'language', 'tool', 'when', 'want'], ['train', 'people', 'be', 'big', 'red', 'flag', 'wide', 'adoption', 'a', 'successful'], ['programming', 'language', 'adaptable', 'different', 'development'], ['process'], ['handle', 'error', 'properly', 'case', 'panic'], ['-PRON-', 'suggest', 'panic', 'everything_.', '-PRON-', 'suggest', 'be'], ['better', 'panic', 'ignore', 'error'], ['unfortunately', 'corrupt', 'datum', 'hard', 'debug', 'code', 'not'], ['bite', 'original', 'author', 'code', 'user'], ['people', 'company'], ['аspects', 'problem'], ['the', 'convention', 'go', 'library', 'package', 'use'], ['panic', 'internally', 'external', 'api', 'present', 'explicit', 'error'], ['panic', 'mean', 'go', 'wrong', 'the', 'sense', 'wrong'], ['depend', 'context', 'case', 'library', 'end', 'user', 'app'], ['different'], ['e', '=', 'nil', 'e', '=', 'nil', 'occur'], [], ['exist', 'omit', 'result', 'value', 'variable', 'the', 'use', 'harmful'], ['i.e.', 'f', '=', 'os', 'open("name', 'f', 'nil', 'nil', 'pointer', 'panic', 'occur'], ['make', 'error', 'handle', 'special', 'lead', 'exception'], ['java', 'c++', 'but', 'os', 'error', 'error', 'and', 'error', 'tend'], ['result', 'value'], ['in', 'experience', '-PRON-', 'think', 'short', 'way', 'panic', 'error'], ['nil', 'convenient'], ['let', '-PRON-', 'consider', 'api', 'look', 'mysql', 'redis', 'library', 'go'], ['db', 'opendb(name', 'string', 'db', 'error'], ['db.(*db).get(key', 'byte', 'byte', 'error'], ['db.(*db).exists(key', 'byte', 'bool', 'error'], ['db.(*db).put(key', 'value', 'byte', 'error'], ['error', 'ouf', 'memory', 'diskspace', 'network', 'problem'], ['and', 'app', 'handle', 'request', 'manipulate', 'database'], ['aspects'], ['db', 'api', 'definitely', 'return', 'error', 'see', 'aspect'], ['-PRON-', 'check', 'opendb', "'s", 'error', 'but', 'checking', 'get', 'exists', 'put'], ['lead', 'endless', 'e', '=', 'nil', 'e', '=', 'nil'], ['e', '=', 'nil', 'sensible', 'context'], ['error', 'mean', 'go', 'wrong'], ['possible', 'solution'], ['make', 'wrapper', 'package', 'application', 'mustget(key', 'byte'], ['byte', 'mustexists(key', 'byte', 'bool', 'mustput(key', 'value', 'byte'], ['some', 'approach', 'be', '-PRON-', 'wrong', 'inconvenience', 'exist', 'or'], ['insignificant'], ['hi'], ['-PRON-', 'release', 'jsondoc', 'command', 'line', 'tool', 'simplify', 'creation'], ['documentation', 'http', 'rest', 'json', 'api', 'project', 'write', 'go', 'the'], ['input', 'and/or', 'output', 'json', 'structure', 'particular', 'endpoint', 'obtain'], ['name', 'type', 'select', 'go', 'package', 'the', 'output', 'jsondoc'], ['html', 'file', 'embed', 'css'], ['example', 'output'], ['repo', 'description'], ['regards'], ['łukasz', 'pankowski'], ['-PRON-', 'package', 'provide'], ['want'], ['cool', 'can', 'build', 'have', 'testing', 'error', 'look', 'later'], ['-PRON-', 'be', 'probably', 'old', 'version', 'go'], ['exec', 'instead', 'os', 'exec'], ['-PRON-', 'not', 'version', 'go'], ['-PRON-', 'will', 'lot', 'work', 'change', 'fuse', ' ', 'just', 'roll', 'early'], ['version', 'fuse', 'tag', 'r60', 'go'], ['version', 'late', 'weekly'], ['$', 'g', '-v'], ['g', 'version', 'release.r60.3'], ['let', 'try', 'change', 'code', 'fuse'], ['hi'], ['below', '-PRON-', 'face', 'any', 'idea'], ['$', 'env', '|', 'grep', 'go'], ['gobin=/home', 'xiaofengguo', 'code', 'hg', 'bin'], ['goarch', '=', 'amd64'], ['goroot=/home', 'xiaofengguo', 'code', 'hg'], ['goos', '=', 'linux'], ['gopath=/home', 'xiaofengguo', 'code', 'hg'], ['$', 'g', 'mount.go'], ['mount.go:7', 'not', 'find', 'import', 'os', 'exec'], ['best', 'regards'], ['xiaofeng'], ['everything', 'exp', 'experimental', 'committed'], ['rest', 'standard', 'distribution', ' ', 'iterating', 'datum'], ['structure', 'channel', 'powerful', 'cheap'], ['simple', 'loop', ' ', 'most', 'go', 'code', 'use', 'idiom'], ['redeem', 'reason', 'like', 'make', 'code'], ['lot', 'easy', 'write'], ['russ'], ['tiny_dust', '<', 'ustc....@gmail.com', '>', 'write'], ['reference', 'equivalent', 'pointer', 'introduce'], ['implicit', 'operation', 'not', 'pointer', 'pointer', ' ', 'neither'], ['change', 'desirable', ' ', 'nobody', 'force', 'use', 'pointer'], ['useful', 'construct', 'language', 'like', 'go', 'give'], ['control', 'memory', 'layout', 'datum'], ['no', 'not', 'change', ' ', 'an', 'expression'], ['statement', 'start', 'struct', '\n\t', 'struct', ' \n', 'block', 'statement', 'start']]
Dictionary(51 unique tokens: ['go', 'point', ' ', 'be', '-PRON-']...)
<gensim.interfaces.TransformedCorpus object at 0x7f167b0269b0>
Topic : 0
pron code package think need like know error csv people
Topic : 1
work version thank app early start release r60 fuse gdb
Topic : 2
write want library os pointer case function exec point byte
Topic : 3
struct err quote field simple russ statement new replace request
Topic : 4
com gmail write datum mount type garbage import collector memory
Topic : 5
value return error panic nil function character err stack bar
Topic : 6
language pron way easy use datum like come write problem
Topic : 7
use code change hg home xiaofengguo just proposal string request
Topic : 8
error program ignore handle handling panic db want structure object
Topic : 9
hi chris stop interface amd64 dollin allusive future ben map
  (0, 604)	1
  (0, 494)	1
  (0, 650)	1
  (0, 441)	1
